# network_diffusions ----

## class ----

#' Network diffusion class
#'
#' @description
#' This class helps to do diffusion of seed nodes in a single or tied version
#' over a network, measure the ability of these diffusion vectors to recall
#' against a gold standard set of nodes and do community detection within the
#' subset of the network that received the the most heat from the initial seed
#' genes.
#'
#' @section Properties:
#' \describe{
#'   \item{graph}{igraph. The underlying graph.}
#'   \item{diffusion_res}{Numeric vector. Contains contains the single or tied
#'   diffusion results.}
#'   \item{params}{A (nested) list that will store all the parameters of the
#'   applied function.}
#'   \item{final_results}{data.table. Contains final results.}
#' }
#'
#' @param edge_data_frame data.table that contains the edge information. It is
#' expected to have the columns 'from' and 'to'.
#' @param weighted Boolean. Is the graph weighted. If set to TRUE, the
#' `edge_data_frame` needs to have a weight column.
#' @param directed Boolean. Shall the graph be stored as directed.
#'
#' @return Returns the `network_diffusions` class for further operations.
#'
#' @export
network_diffusions <- S7::new_class(
  # Names, parents
  name = "network_diffusions",
  parent = bixverse_base_class,

  # Properties, i.e., slots
  properties = list(
    graph = S7::class_any,
    diffusion_res = S7::class_numeric,
    final_results = S7::class_data.frame,
    params = S7::class_list
  ),


  constructor = function(edge_data_frame, weighted, directed) {
    # Checks
    needed_cols <- if (weighted) {
      c("from", "to", "weight")
    } else {
      c("from", "to")
    }
    checkmate::assertDataTable(edge_data_frame)
    checkmate::assertNames(names(edge_data_frame), must.include = needed_cols)
    checkmate::qassert(weighted, "B1")
    checkmate::qassert(directed, "B1")
    # Function body
    graph <- if (weighted) {
      igraph::graph_from_data_frame(edge_data_frame, directed = directed)
    } else {
      igraph::graph_from_data_frame(edge_data_frame[, c("from", "to")], directed = directed)
    }

    if(!weighted)


    params <- list(
      "directed_graph" = igraph::is_directed(graph),
      "weighted_graph" = igraph::is_weighted(graph)
    )

    # Finalise object
    S7::new_object(
      S7::S7_object(),
      graph = graph,
      diffusion_res = vector(mode = "numeric"),
      final_results = data.table(),
      params = params
    )
  }
)

## methods ----

### getters ----

#' Get the diffusion vector
#'
#' @description Returns the diffusion vector if you ran [bixverse::tied_diffusion()]
#' or [bixverse::diffuse_seed_nodes()].
#'
#' @param object The underlying class [bixverse::network_diffusions()].
#'
#' @return The diffusion vector if found. If you did not run either diffusion
#' functions, it will return `NULL` and a warning.
#'
#' @export
get_diffusion_vector <- S7::new_generic(
  name = "get_diffusion_vector",
  dispatch_args = "object",
  fun = function(object) {
    S7::S7_dispatch()
  }
)

#' @export
#'
#' @importFrom magrittr `%>%`
#'
#' @method get_diffusion_vector network_diffusions
S7::method(get_diffusion_vector, network_diffusions) <- function(object) {
  # Checks
  checkmate::assertClass(object, "bixverse::network_diffusions")
  # Get the data
  diffusion_vec <- S7::prop(object, "diffusion_res")
  if (is.null(diffusion_vec))
    warning("No diffusion results found. Returning NULL.")
  diffusion_vec
}

# rbh_graphs ----

## class ----

rbh_graph <- S7::new_class(
  # Names, parents
  name = "rbh_graph",
  parent = bixverse_base_class,

  # Properties, i.e., slots
  properties = list(
    module_data = S7::class_list,
    rbh_graph = S7::class_any,
    rbh_edge_df = S7::class_data.frame,
    final_results = S7::class_data.frame,
    params = S7::class_list
  ),

  #' Reciprocal best hit graph
  #'
  #' @description
  #' This class can be used to generate reciprocal best hit graphs between
  #' gene modules from different origins.
  #'
  #' Internal properties:
  #' - module_data: Nested list of the modules generated by different methods.
  #' - rbh_graph: The reciprocal best hit igraph.
  #' - rbh_edge_df: Edge data.table with the information from the reciprocal
  #' best hits.
  #' - final_results: This is where the final communities will be stored.
  #' - params: A list with the params. This will be populated during subsequent
  #' function calls.
  #'
  #' @param module_results data.table with the all of the gene modules for which
  #' you wish to generate the RBH graph.
  #' @param dataset_col The column (name) which indicates from which data set/
  #' method the gene module was derived.
  #' @param module_col The column (name) which stores the names of the modules.
  #' @param value_col The column (name) which stores the genes that are part of
  #' the modules.
  #'
  #' @return Returns the `rbh_graph` class for further operations.
  #'
  #' @export
  constructor = function(module_results,
                         dataset_col,
                         module_col,
                         value_col) {
    checkmate::assertDataTable(module_results)
    checkmate::qassert(dataset_col, "S1")
    checkmate::qassert(module_col, "S1")
    checkmate::qassert(value_col, "S1")
    checkmate::assertNames(names(module_results),
      must.include = c(dataset_col, module_col, value_col)
    )
    # Function body
    list_of_list <- split(
      module_results %>% dplyr::select(!!module_col, !!value_col),
      module_results[, ..dataset_col]
    ) %>%
      purrr::map(., ~ {
        df <- .
        split(unlist(df[, ..value_col]), unlist(df[, ..module_col]))
      })

    # Finalise object
    S7::new_object(
      S7::S7_object(),
      module_data = list_of_list,
      rbh_edge_df = data.table(),
      rbh_graph = NULL,
      final_results = data.table(),
      params = list(
        no_compared_modules = nrow(module_results)
      )
    )
  }
)

## methods ----


