# meta cell class --------------------------------------------------------------

## s7 object -------------------------------------------------------------------

#' @title bixverse meta cell class
#'
#' @description
#' This is the `bixverse`-based meta cell class. It is generated by running
#' meta-cell generating functions on top of the main class. Due to the
#' aggregation of the count matrices to a way smaller number of meta cells,
#' the data is held in memory for this class specifically. Additional methods
#' that make specific usage of meta cells (especially co-expression module
#' detection ones will be made available).
#'
#' @param meta_cell_data Named list. Output of meta-cell generation Rust
#' functions. Will contain the aggregated raw and normalised counts, plus
#' additional information on the origin of the meta cells.
#' @param var_data data.table with the variable/feature informations.
#' @param meta_cell_method String describing the origin of the metacell.
#'
#' @section Properties:
#' \describe{
#'   \item{obs_table}{The meta cell observation table.}
#'   \item{var_table}{The meta cell variable table.}
#'   \item{data}{List with the raw and normalised counts.}
#'   \item{original_assignment}{List with original assignment information.}
#'   \item{dims}{Dimensions of the new meta cell matrices.}
#'   \item{other_data}{Potential other data returned from the meta-cell
#'   generating methods.}
#' }
#'
#' @return Returns the `meta_cells` class for further operations.
#'
#' @export
meta_cells <- S7::new_class(
  name = "meta_cells",
  properties = list(
    obs_table = S7::class_data.frame,
    var_table = S7::class_data.frame,
    data = S7::class_list,
    original_assignment = S7::class_list,
    dims = S7::class_integer,
    other_data = S7::class_list,
    meta_cell_method = S7::class_character
  ),
  constructor = function(meta_cell_data, var_data, meta_cell_method) {
    # checks
    checkmate::assertList(meta_cell_data)
    checkmate::assertNames(
      names(meta_cell_data),
      must.include = c("aggregated", "assignments")
    )
    checkmate::assertDataTable(var_data)
    checkmate::assertNames(
      names(var_data),
      must.include = c("gene_idx", "gene_id")
    )
    checkmate::qassert(meta_cell_method, "S1")

    # function body
    n_digits <- nchar(as.character(meta_cell_data$assignments$n_metacells))
    format_str <- sprintf("meta_cell_%%0%dd", n_digits)

    obs_data <- data.table::data.table(
      meta_cell_idx = 1:meta_cell_data$assignments$n_metacells,
      meta_cell_id = sprintf(
        format_str,
        1:meta_cell_data$assignments$n_metacells
      ),
      no_originating_cells = purrr::map_dbl(
        meta_cell_data$assignments$metacells,
        length
      ),
      original_cell_idx = meta_cell_data$assignments$metacells
    )

    c(raw_counts, norm_counts) %<-%
      get_meta_cell_matrices(meta_cell_data$aggregated)

    rownames(raw_counts) <- rownames(norm_counts) <- obs_data$meta_cell_id
    colnames(raw_counts) <- colnames(norm_counts) <- var_data$gene_id

    other_data <- if (meta_cell_method == "seacell") {
      list(
        rss = meta_cell_data$rss,
        archetypes = meta_cell_data$archetypes
      )
    } else {
      list()
    }

    S7::new_object(
      S7::S7_object(),
      obs_table = obs_data,
      var_table = var_data,
      data = list(raw = raw_counts, norm = norm_counts),
      original_assignment = meta_cell_data$assignments[c(
        "assignments",
        "n_cells",
        "n_metacells",
        "n_unassigned"
      )],
      dims = as.integer(c(nrow(raw_counts), ncol(norm_counts))),
      other_data = other_data,
      meta_cell_method = meta_cell_method
    )
  }
)

## getters ---------------------------------------------------------------------

### obs ------------------------------------------------------------------------

#' @method get_sc_obs meta_cells
#'
#' @export
S7::method(get_sc_obs, meta_cells) <- function(
  object,
  indices = NULL,
  cols = NULL,
  filtered = FALSE
) {
  checkmate::assertClass(object, "bixverse::meta_cells")
  checkmate::qassert(indices, c("0", "I+"))
  checkmate::qassert(filtered, "B1")

  obs_table <- data.table::copy(S7::prop(object, "obs_table"))

  if (!is.null(indices)) {
    obs_table <- obs_table[indices, ]
  }

  if (!is.null(cols)) {
    obs_table <- obs_table[, cols, with = FALSE]
  }

  return(obs_table)
}

#' @method `[[` meta_cells
#'
#' @export
S7::method(`[[`, meta_cells) <- function(x, i, ...) {
  if (missing(i)) {
    i <- NULL
  }
  if (checkmate::qtest(i, "S+")) {
    get_sc_obs(x, cols = i, filtered = FALSE)
  } else if (checkmate::qtest(i, "I+")) {
    get_sc_obs(x, indices = i, filtered = FALSE)
  } else if (checkmate::qtest(i, "0")) {
    get_sc_obs(x, filtered = FALSE)
  } else {
    stop("Invalid type")
  }
}

### vars -----------------------------------------------------------------------

#' @method get_sc_var meta_cells
#'
#' @export
S7::method(get_sc_var, meta_cells) <- function(
  object,
  indices = NULL,
  cols = NULL
) {
  checkmate::assertClass(object, "bixverse::meta_cells")
  checkmate::qassert(indices, c("0", "I+"))

  var_table <- object@var_table

  if (!is.null(indices)) {
    var_table <- var_table[indices, ]
  }

  if (!is.null(cols)) {
    var_table <- var_table[, cols, with = FALSE]
  }

  return(var_table)
}

### counts ---------------------------------------------------------------------

#' @method get_sc_counts meta_cells
#'
#' @export
S7::method(get_sc_counts, meta_cells) <- function(
  object,
  assay = c("raw", "norm"),
  return_format = c("cell", "gene"),
  cell_indices = NULL,
  gene_indices = NULL,
  use_cells_to_keep = TRUE,
  .verbose = TRUE
) {
  checkmate::assertClass(object, "bixverse::meta_cells")
  assay <- match.arg(assay)

  counts <- S7::prop(object, "data")[[assay]]

  if (!is.null(cell_indices)) {
    counts <- counts[cell_indices, , drop = FALSE]
  }

  if (!is.null(gene_indices)) {
    counts <- counts[, gene_indices, drop = FALSE]
  }

  return(counts)
}

#' @method `[` meta_cells
#'
#' @export
S7::method(`[`, meta_cells) <- function(
  x,
  i,
  j,
  ...,
  assay = c("raw", "norm"),
  drop = TRUE
) {
  if (missing(i)) {
    i <- NULL
  }
  if (missing(j)) {
    j <- NULL
  }
  assay <- match.arg(assay)

  checkmate::qassert(i, c("I+", "0"))
  checkmate::qassert(j, c("I+", "0"))
  checkmate::assertChoice(assay, c("raw", "norm"))

  get_sc_counts(
    object = x,
    assay = assay,
    cell_indices = i,
    gene_indices = j
  )
}

## setters ---------------------------------------------------------------------

### obs table ------------------------------------------------------------------

#' @method `[[<-` meta_cells
#'
#' @export
S7::method(`[[<-`, meta_cells) <- function(x, i, ..., value) {
  checkmate::assertClass(x, "bixverse::meta_cells")
  checkmate::qassert(i, "S+")

  if (length(i) == 1) {
    checkmate::qassert(value, "a")
    S7::prop(x, "obs_table")[, (i) := value]
  } else {
    checkmate::assertList(value, names = "named", types = "atomic")
    S7::prop(x, "obs_table")[, (i) := value]
  }

  return(x)
}
