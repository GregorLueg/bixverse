# Generated by extendr: Do not edit by hand

# nolint start

#
# This file was created with the following call:
#   .Call("wrap__make_bixverse_wrappers", use_symbols = TRUE, package_name = "bixverse")

#' @usage NULL
#' @useDynLib bixverse, .registration = TRUE
NULL

#' Run a single hypergeometric test.
#' 
#' Given a set of target genes, this is a Rust implementation of an hypergeometric 
#' test testing for overenrichment of the target genes in the gene sets.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param target_genes A character vector representing the target gene set.
#' @param gene_sets A list of strings that represent the gene sets to test against.
#' @param gene_universe A character vector representing the gene universe from 
#' which the target genes
#' and gene sets are sampled from.
#' 
#' @return A list containing:
#'  \itemize{
#'   \item pvals - The p-values from the hypergeometric test
#'   \item odds_ratios - The calculated odds ratios
#'   \item overlap - The size of the overlap
#'   \gene_set_lengths - The length of the gene sets.
#' }
#' 
#' @export
rs_hypergeom_test <- function(target_genes, gene_sets, gene_universe) .Call(wrap__rs_hypergeom_test, target_genes, gene_sets, gene_universe)

#' Run a hypergeometric test over a list of target genes
#' 
#' Given a list of target gene sets, this function will test for each of the individual 
#' target genes the hypergeoemetric enrichment against the specified gene sets.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param target_genes A character vector representing the target gene set.
#' @param gene_sets A list of strings that represent the gene sets to test against.
#' @param gene_universe A character vector representing the gene universe from which the target genes
#' and gene sets are sampled from.
#' 
#' @return A list containing:
#'  \itemize{
#'   \item pvals - The p-values from the hypergeometric test
#'   \item odds ratios - The calculated odds ratios
#'   \item overlap - The size of the overlap
#'   \gene_set_lengths - The length of the gene sets.
#' }
#' 
#' @export
rs_hypergeom_test_list <- function(target_genes_list, gene_sets, gene_universe) .Call(wrap__rs_hypergeom_test_list, target_genes_list, gene_sets, gene_universe)

#' Run hypergeometric enrichment over the gene ontology
#' 
#' This function implements a Rust version of the gene ontology enrichment with elimination:
#' the starting point are the leafs of the ontology and hypergeometric tests will first conducted there.
#' Should the hypergeometric test p-value be below a certain threshold, the genes of that gene ontology
#' term will be removed from all ancestors.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param target_genes A character vector representing the target gene set.
#' @param go_to_genes A named list with the gene identifers as elements and gene ontology identifiers as 
#' names.
#' @param ancestors A named list with the go identifiers of all ancestors as elements and the gene ontology
#' identifiers as names.
#' @param levels A named list with the go identifiers of that ontology level as elements and the level name
#' as names. IMPORTANT! This list needs to be ordered in the right way!
#' @param gene_universe_length The length of the gene universe.
#' @param min_genes number of minimum genes for the gene ontology term to be tested.
#' @param elim_threshold p-value below which the elimination procedure shall be applied to the ancestors.
#' @param debug boolean that will provide additional console information for debugging purposes.
#' 
#' @return A list containing:
#'  \itemize{
#'   \item go_ids - The gene ontology identifier.
#'   \item pvals - The calculated odds ratios.
#'   \item odds_ratios - The calculated odds ratios.
#'   \item overlap - The size of the overlap.
#'   \gene_set_lengths - The length of the gene sets.
#' }
#' 
#' @export
rs_gse_geom_elim <- function(target_genes, go_to_genes, ancestors, levels, gene_universe_length, min_genes, elim_threshold, debug) .Call(wrap__rs_gse_geom_elim, target_genes, go_to_genes, ancestors, levels, gene_universe_length, min_genes, elim_threshold, debug)

#' Run hypergeometric enrichment a list of target genes over the gene ontology
#' 
#' This function implements a Rust version of the gene ontology enrichment with elimination:
#' the starting point are the leafs of the ontology and hypergeometric tests will first conducted there.
#' Should the hypergeometric test p-value be below a certain threshold, the genes of that gene ontology
#' term will be removed from all ancestors. This function is designed to leverage Rust-based threading
#' for parallel processing of a list of target genes.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param target_genes_list A list of target genes against which to run the method.
#' @param go_to_genes A named list with the gene identifers as elements and gene ontology identifiers as 
#' names.
#' @param ancestors A named list with the go identifiers of all ancestors as elements and the gene ontology
#' identifiers as names.
#' @param levels A named list with the go identifiers of that ontology level as elements and the level name
#' as names. IMPORTANT! This list needs to be ordered in the right way!
#' @param gene_universe_length The length of the gene universe.
#' @param min_genes number of minimum genes for the gene ontology term to be tested.
#' @param elim_threshold: p-value below which the elimination procedure shall be applied to the ancestors.
#' @param debug boolean that will provide additional console information for debugging purposes.
#' 
#' @return A list containing:
#'  \itemize{
#'   \item go_ids - The gene ontology identifier.
#'   \item pvals - The calculated odds ratios.
#'   \item odds_ratios - The calculated odds ratios.
#'   \item overlap - The size of the overlap.
#'   \item gene_set_lengths - The length of the gene sets.
#'   \item no_test - The number of tests that were conducted against target_gene_list.
#'   First element indicates how many values belong to the first target_genes set 
#'   in the list, etc.
#' }
#' 
#' @export
rs_gse_geom_elim_list <- function(target_genes_list, go_to_genes, ancestors, levels, gene_universe_length, min_genes, elim_threshold, debug) .Call(wrap__rs_gse_geom_elim_list, target_genes_list, go_to_genes, ancestors, levels, gene_universe_length, min_genes, elim_threshold, debug)

#' Fast AUC calculation
#' 
#' @description This function calculates rapidly AUCs based on an approximation.
#' 
#' @param pos_scores The scores of your hits.
#' @param neg_scores The scores of your non-hits.
#' @param iters Number of iterations to run the function for. 
#' Recommended size: 10000L.
#' @param random_seed Seed.
#' 
#' @return The AUC.
#' 
#' @export
rs_fast_auc <- function(pos_scores, neg_scores, iters, seed) .Call(wrap__rs_fast_auc, pos_scores, neg_scores, iters, seed)

#' Create random AUCs
#' 
#' @description This function creates a random set of AUCs based on a score vector 
#' and a size of the positive set. This can be used for permutation-based estimation
#' of Z-scores and subsequently p-values.
#' 
#' @param score_vec The overall vector of scores.
#' @param size_pos The size of the hits represented in the score_vec.
#' @param random_iters Number of random AUCs to generate.
#' @param auc_iters Number of random iterations to approximate the AUCs. 
#' Recommended size: 10000L.
#' @param seed Seed.
#' 
#' @return A vector of random AUCs based the score vector and size of the positive set.
#' 
#' @export
rs_create_random_aucs <- function(score_vec, size_pos, random_iters, auc_iters, seed) .Call(wrap__rs_create_random_aucs, score_vec, size_pos, random_iters, auc_iters, seed)

#' Calculate the OT harmonic sum
#' 
#' @param x The numeric vector (should be between 0 and 1) for which to 
#' calculate the harmonic sum
#' 
#' @return Returns the harmonic sum according to the OT calculation.
#' 
#' @export
rs_ot_harmonic_sum <- function(x) .Call(wrap__rs_ot_harmonic_sum, x)

#' @export
rs_hypergeom <- function(q, m, n, k) .Call(wrap__rs_hypergeom, q, m, n, k)

#' Generate reciprocal best hits based on set similarities
#' 
#' @description This function takes a nested list that contains gene modules/sets 
#' derived from various methods and generate identifies reciprocal best hits between 
#' gene modules/sets across the different origins.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param module_list A nested named list. The outer list should contain the 
#' origin of the gene modules, the inner list the names of the gene modules and
#' the respective genes in them.
#' @param overlap_coefficient Shall the overlap coefficient instead of the 
#' Jaccard similarity be used.
#' @param min_similarity Minimum similarity that should exist between any two 
#' given gene modules to actually calculate RBH pairs.
#' @param debug Boolean Boolean that activates print messages for debugging purposes.
#' 
#' @return A list containing:
#'  \itemize{
#'   \item origin - The name of the origin of the gene modules.
#'   \item target - The name of the target of the gene modules.
#'   \item comparisons - Integer vector indicating how many RBH hits were identified in this comparison
#'   \item origin_modules - Names of the gene modules from the origin.
#'   \item target_modules - Names of the gene modules from the target.
#'   \item similarity - The similarities between the two respective gene modules.
#' }
#' @export
rs_rbh_sets <- function(module_list, overlap_coefficient, min_similarity, debug) .Call(wrap__rs_rbh_sets, module_list, overlap_coefficient, min_similarity, debug)

#' Calculate the column-wise co-variance.
#' 
#' @description Calculates the co-variance of the columns.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param x R matrix with doubles.
#' 
#' @returns The co-variance matrix.
#' 
#' @export
rs_covariance <- function(x) .Call(wrap__rs_covariance, x)

#' Calculate the contrastive PCA
#' 
#' @description This function calculate the contrastive PCA given a target
#' covariance matrix and the background covariance matrix you wish to subtract.
#' The alpha parameter controls how much of the background covariance you wish
#' to remove. You have the options to return the feature loadings and you can
#' specificy the number of cPCAs to return.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param target_covar The co-variance matrix of the target data set.
#' @param background_covar The co-variance matrix of the background data set.
#' @param target_mat The original values of the target matrix.
#' @param alpha How much of the background co-variance should be removed.
#' @param n_pcs How many contrastive PCs to return
#' @param return_loadings Shall the loadings be returned from the contrastive
#' PCA
#' 
#' @return A list containing:
#'  \itemize{
#'   \item factors - The factors of the contrastive PCA.
#'   \item loadings - The loadings of the contrastive PCA. Will be NULL if 
#'    return_loadings is set to FALSE.
#' }
#' 
#' @export
rs_contrastive_pca <- function(target_covar, background_covar, target_mat, alpha, n_pcs, return_loadings) .Call(wrap__rs_contrastive_pca, target_covar, background_covar, target_mat, alpha, n_pcs, return_loadings)

#' Prepare the data for whitening
#' 
#' @description Prepares the data for subsequent usag in ICA.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param x The matrix to whiten. The whitening will happen over the columns.
#' 
#' @return A list containing:
#'  \itemize{
#'   \item x - The transposed and scaled data for subsequent usage in ICA.
#'   \item k - The K matrix.
#' }
#' 
#' @export
rs_prepare_whitening <- function(x) .Call(wrap__rs_prepare_whitening, x)

#' Run the Rust implementation of fast ICA.
#' 
#' @description This function serves as a wrapper over the fast ICA implementations
#' in Rust. It assumes a pre-whiten matrix and also an intialised w_init.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#' 
#' @param whiten The whitened matrix.
#' @param w_init The w_init matrix. ncols need to be equal to nrows of whiten.
#' @param maxit Maximum number of iterations to try if algorithm does not converge.
#' @param alpha The alpha parameter for the LogCosh implementation of ICA.
#' @param tol Tolerance parameter.
#' @param ica_type One of 'logcosh' or 'exp'.
#' @param verbose Controls the verbosity of the function.
#' @param debug Additional messages if desired.
#' 
#' @param x The matrix to whiten. The whitening will happen over the columns.
#' 
#' @return A list containing:
#'  \itemize{
#'   \item mixing - The mixing matrix for subsequent usage.
#'   \item converged - Boolean if the algorithm converged.
#' }
#' 
#' @export
rs_fast_ica <- function(whiten, w_init, maxit, alpha, tol, ica_type, verbose) .Call(wrap__rs_fast_ica, whiten, w_init, maxit, alpha, tol, ica_type, verbose)

#' @export
rs_cor <- function(x, spearman) .Call(wrap__rs_cor, x, spearman)


# nolint end
