# Generated by extendr: Do not edit by hand

# nolint start

#
# This file was created with the following call:
#   .Call("wrap__make_bixverse_wrappers", use_symbols = TRUE, package_name = "bixverse")

#' @usage NULL
#' @useDynLib bixverse, .registration = TRUE
NULL

#' Calculates the traditional GSEA enrichment score
#'
#' @param stats Named numerical vector. Needs to be sorted. The gene level statistics.
#' @param pathway_r String vector. The genes in the pathway.
#'
#' @return The enrichment score
#'
#' @export
rs_calc_es <- function(stats, pathway_r) .Call(wrap__rs_calc_es, stats, pathway_r)

#' Helper function to rapidly retrieve the indices of the gene set members
#'
#' @param gene_universe Character Vector. The genes represented in the gene universe.
#' @param pathway_list List. A named list with each element containing the genes for this
#' pathway.
#'
#' @return Returns a list with the index positions of the gene set genes in the gene universe.
#' Importantly, these are indexed to R's 1-indexing!
#'
#' @export
rs_get_gs_indices <- function(gene_universe, pathway_list) .Call(wrap__rs_get_gs_indices, gene_universe, pathway_list)

#' Rust implementation of the fgsea::calcGseaStat() function
#'
#' @param stats Numeric vector. The gene level statistic. Needs to
#' sorted in descending nature.
#' @param gs_idx Integer vector. The indices of the gene set genes.
#' @param gsea_param Float. The GSEA parameter. Usually defaults to 1.0.
#' @param return_leading_edge Boolean. Return the leading edge indices.
#'
#' @return List with the following elements
#' \itemize{
#'     \item gene_stat Enrichment score for that gene set
#'     \item leading_edge Indicies of the leading edge genes.
#' }
#'
#' @export
rs_calc_gsea_stats <- function(stats, gs_idx, gsea_param, return_leading_edge) .Call(wrap__rs_calc_gsea_stats, stats, gs_idx, gsea_param, return_leading_edge)

#' Helper function to generate fgsea simple-based permutations
#'
#' @param stats Numeric vector. The gene level statistic. Needs to
#' sorted in descending nature.
#' @param pathway_scores Numeric vector. The enrichment scores for the
#' pathways
#' @param pathway_sizes Integer vector. The sizes of the pathways.
#' @param iters Integer. Number of permutations.
#' @param gsea_param Float. The Gene Set Enrichment parameter.
#' @param return_add_stats Boolean. Returns additional statistics
#' necessary for the multi-level calculations.
#' @param seed Integer. For reproducibility purposes
#'
#' @return List with the following elements
#' \itemize{
#'     \item es Enrichment scores for the gene sets
#'     \item nes Normalised enrichment scores for the gene sets
#'     \item pvals The calculated p-values.
#'     \item n_more_extreme Number of times the enrichment score was
#'     bigger or smaller than the permutation (pending sign).
#'     \item size Pathway size.
#' }
#'
#' If `return_add_stats` is set to true, there is additional elements in the
#' list:
#' \itemize{
#'     \item le_zero Number of times the permutation was less than zero.
#'     \item ge_zero Number of times the permutation was greater than zero.
#' }
#'
#' @export
rs_calc_gsea_stat_cumulative_batch <- function(stats, pathway_scores, pathway_sizes, iters, gsea_param, return_add_stats, seed) .Call(wrap__rs_calc_gsea_stat_cumulative_batch, stats, pathway_scores, pathway_sizes, iters, gsea_param, return_add_stats, seed)

#' Helper function to generate traditional GSEA-based permutations
#'
#' @param stats Numeric vector. The gene level statistic. Needs to
#' sorted in descending nature.
#' @param pathway_scores Numeric vector. The enrichment scores for the
#' pathways
#' @param pathway_sizes Integer vector. The sizes of the pathways.
#' @param iters Integer. Number of permutations.
#' @param seed Integer For reproducibility purposes
#'
#' @return List with the following elements
#' \itemize{
#'     \item es Enrichment scores for the gene sets
#'     \item nes Normalised enrichment scores for the gene sets
#'     \item pvals The calculated p-values.
#'     \item n_more_extreme Number of times the enrichment score was
#'     bigger or smaller than the permutation (pending sign).
#'     \item size Pathway size.
#' }
#'
#' @export
rs_calc_gsea_stat_traditional_batch <- function(stats, pathway_scores, pathway_sizes, iters, seed) .Call(wrap__rs_calc_gsea_stat_traditional_batch, stats, pathway_scores, pathway_sizes, iters, seed)

#' Calculates p-values for pre-processed data
#'
#' @param stats Named numerical vector. Needs to be sorted. The gene level statistics.
#' @param es Numerical vector. The enrichment scores of the pathways of that specific size
#' @param pathway_size Integer. The size of the pathways to test.
#' @param sample_size Integer. The size of the random gene sets to test against.
#' @param seed Integer. Random seed.
#' @param eps Float. Boundary for calculating the p-value.
#' @param sign Boolean. Used for the only positive or only negative score version.
#'
#' @return List with the following elements:
#' \itemize{
#'     \item pvals The pvalues.
#'     \item is_cp_ge_half Flag indicating if conditional probability is ≥ 0.5. Indicates
#'     overesimation of the p-values.
#' }
#'
#' @export
rs_calc_multi_level <- function(stats, es, pathway_size, sample_size, seed, eps, sign) .Call(wrap__rs_calc_multi_level, stats, es, pathway_size, sample_size, seed, eps, sign)

#' Run fgsea simple method for gene ontology with elimination method
#'
#' @param stats Named numerical vector. Needs to be sorted. The gene level statistics.
#' @param levels A character vector representing the levels to iterate through.
#' The order will be the one the iterations are happening in.
#' @param go_obj The gene_ontology_data S7 class. See [bixverse::gene_ontology_data()].
#' @param gsea_params List. The GSEA parameters, see [bixverse::params_gsea()]
#' wrapper function. This function generates a list containing:
#' \itemize{
#'     \item min_size - Integer. Minimum size for the gene sets.
#'     \item max_size - Integer. Maximum size for the gene sets.
#'     \item gsea_param - Float. The GSEA parameter. Defaults to `1.0`.
#'     \item sample_size - Integer. Number of samples to iterate through for the
#'     multi-level implementation of fgsea.
#'     \item eps - Float. Boundary for calculating the p-value. Used for the multi-
#'     level implementation of fgsea.
#' }
#' @param elim_threshold p-value below which the elimination procedure shall be
#' applied to the ancestors.
#' @param iters Integer. Number of random permutations for the fgsea simple method
#' to use
#' @param seed Integer. For reproducibility purposes.
#' @param debug Boolean that will provide additional console information for
#' debugging purposes.
#'
#' @return List with the following elements
#' \itemize{
#'     \item go_ids The name of the tested gene ontology identifer.
#'     \item es The enrichment scores for the pathway
#'     \item nes The normalised enrichment scores for the pathway
#'     \item size The pathway sizes (after elimination!).
#'     \item pvals The p-values for this pathway based on permutation
#'     testing
#'     \item n_more_extreme Number of times the enrichment score was
#'     bigger or smaller than the permutation (pending sign).
#'     \item le_zero Number of times the permutation was less than zero.
#'     \item ge_zero Number of times the permutation was greater than zero.
#'     \item leading_edge A list of the index positions of the leading edge
#'     genes for this given GO term.
#' }
#'
#' @export
rs_geom_elim_fgsea_simple <- function(stats, levels, go_obj, gsea_params, elim_threshold, iters, seed, debug) .Call(wrap__rs_geom_elim_fgsea_simple, stats, levels, go_obj, gsea_params, elim_threshold, iters, seed, debug)

#' Calculates the simple and multi error for fgsea multi level
#'
#' @param n_more_extreme Integer vector. The number of times the ES was larger than the
#' permutations.
#' @param nperm Integer. Number of permutations.
#' @param sample_size Integer. Number of samples.
#'
#' @return List with the following elements:
#' \itemize{
#'     \item simple_err Vector of simple errors.
#'     \item multi_err Vector of multi errors.
#' }
#'
#' @export
rs_simple_and_multi_err <- function(n_more_extreme, nperm, sample_size) .Call(wrap__rs_simple_and_multi_err, n_more_extreme, nperm, sample_size)

#' Run a single hypergeometric test.
#'
#' @description Given a set of target genes, this is a Rust implementation of
#' an hypergeometric test testing for overenrichment of the target genes in the
#' gene sets. WARNING! Incorrect use can cause kernel crashes. Wrapper around
#' the Rust functions with type checks are provided in the package.
#'
#' @param target_genes A character vector representing the target gene set.
#' @param gene_sets A list of strings that represent the gene sets to test against.
#' @param gene_universe A character vector representing the gene universe from
#' which the target genes and gene sets are sampled from.
#'
#' @return A list containing:
#'  \itemize{
#'   \item pvals - The p-values from the hypergeometric test
#'   \item odds_ratios - The calculated odds ratios
#'   \item overlap - The size of the overlap
#'   \item gene_set_lengths - The length of the gene sets.
#' }
#'
#' @export
rs_hypergeom_test <- function(target_genes, gene_sets, gene_universe) .Call(wrap__rs_hypergeom_test, target_genes, gene_sets, gene_universe)

#' Run a hypergeometric test over a list of target genes
#'
#' @description Given a list of target gene sets, this function will test for
#' each of the individual target genes the hypergeoemetric enrichment against
#' the specified gene sets. WARNING! Incorrect use can cause kernel crashes.
#' Wrapper around the Rust functions with type checks are provided in the
#' package.
#'
#' @param target_genes_list A character vector representing the target gene set.
#' @param gene_sets A list of strings that represent the gene sets to test
#' against.
#' @param gene_universe A character vector representing the gene universe from
#' which the target genes and gene sets are sampled from.
#'
#' @return A list containing:
#'  \itemize{
#'   \item pvals - The p-values from the hypergeometric test
#'   \item odds ratios - The calculated odds ratios
#'   \item overlap - The size of the overlap
#'   \item gene_set_lengths - The length of the gene sets.
#' }
#'
#' @export
rs_hypergeom_test_list <- function(target_genes_list, gene_sets, gene_universe) .Call(wrap__rs_hypergeom_test_list, target_genes_list, gene_sets, gene_universe)

#' Run hypergeometric enrichment over the gene ontology
#'
#' @description This function implements a Rust version of the gene ontology
#' enrichment with elimination: the starting point are the leafs of the
#' ontology and hypergeometric tests will first conducted there. Should the
#' hypergeometric test p-value be below a certain threshold, the genes of that
#' gene ontology term will be removed from all ancestors. WARNING! Incorrect
#' use can cause kernel crashes. Wrapper around the Rust functions with type
#' checks are provided in the package.
#'
#' @param target_genes A character vector representing the target gene set.
#' @param levels A character vector representing the levels to iterate through.
#' The order will be the one the iterations are happening in.
#' @param go_obj The gene_ontology_data S7 class. See [bixverse::gene_ontology_data()].
#' @param gene_universe_length The length of the gene universe.
#' @param min_genes number of minimum genes for the gene ontology term to be
#' tested.
#' @param elim_threshold p-value below which the elimination procedure shall be
#' applied to the ancestors.
#' @param debug Boolean that will provide additional console information for
#' debugging purposes.
#'
#' @return A list containing:
#'  \itemize{
#'   \item go_ids - The gene ontology identifier.
#'   \item pvals - The calculated odds ratios.
#'   \item odds_ratios - The calculated odds ratios.
#'   \item overlap - The size of the overlap.
#'   \item gene_set_lengths - The length of the gene sets.
#' }
#'
#' @export
rs_gse_geom_elim <- function(target_genes, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug) .Call(wrap__rs_gse_geom_elim, target_genes, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug)

#' Run hypergeometric enrichment a list of target genes over the gene ontology
#'
#' This function implements a Rust version of the gene ontology enrichment with
#' elimination: the starting point are the leafs of the ontology and
#' hypergeometric tests will first conducted there. Should the hypergeometric
#' test p-value be below a certain threshold, the genes of that gene ontology
#' term will be removed from all ancestors. This function is designed to
#' leverage Rust-based threading for parallel processing of a list of target
#' genes. WARNING! Incorrect use can cause kernel crashes. Wrapper around the
#' Rust functions with type checks are provided in the package.
#'
#' @param target_genes_list A list of target genes against which to run the
#' method.
#' @param levels A character vector representing the levels to iterate through.
#' The order will be the one the iterations are happening in.
#' @param go_obj The gene_ontology_data S7 class. See [bixverse::gene_ontology_data()].
#' @param gene_universe_length The length of the gene universe.
#' @param min_genes number of minimum genes for the gene ontology term to be
#' tested.
#' @param elim_threshold p-value below which the elimination procedure shall
#' be applied to the ancestors.
#' @param debug boolean that will provide additional console information for
#' debugging purposes.
#'
#' @return A list containing:
#'  \itemize{
#'   \item go_ids - The gene ontology identifier.
#'   \item pvals - The calculated odds ratios.
#'   \item odds_ratios - The calculated odds ratios.
#'   \item overlap - The size of the overlap.
#'   \item gene_set_lengths - The length of the gene sets.
#'   \item no_test - The number of tests that were conducted against
#'   target_gene_list. First element indicates how many values belong to the
#'   first target_genes set in the list, etc.
#' }
#'
#' @export
rs_gse_geom_elim_list <- function(target_genes_list, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug) .Call(wrap__rs_gse_geom_elim_list, target_genes_list, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug)

#' Set similarities over list
#'
#' This function calculates the Jaccard or similarity index between a one given
#' string vector and list of vectors.
#'
#' @param s_1_list The String vector against which to calculate the set similarities.
#' @param s_2_list A List of vector against which to calculate the set similarities.
#' @param overlap_coefficient Boolean. Use the overlap coefficient instead of the
#' Jaccard similarity be calculated.
#'
#' @return Vector of set similarities (upper triangle) values.
#'
#' @export
rs_set_similarity_list <- function(s_1_list, s_2_list, overlap_coefficient) .Call(wrap__rs_set_similarity_list, s_1_list, s_2_list, overlap_coefficient)

#' Set similarities
#'
#' This function calculates the Jaccard or similarity index between a two given
#' string vector and a  of other string vectors.
#'
#' @param s_1 The String vector against which to calculate the set similarities.
#' @param s_2 The String vector against which to calculate the set similarities.
#' @param overlap_coefficient Boolean. Use the overlap coefficient instead of the Jaccard similarity be calculated.
#'
#' @export
rs_set_similarity <- function(s_1, s_2, overlap_coefficient) .Call(wrap__rs_set_similarity, s_1, s_2, overlap_coefficient)

#' Fast AUC calculation
#'
#' @description This function calculates rapidly AUCs based on an approximation.
#'
#' @param pos_scores The scores of your hits.
#' @param neg_scores The scores of your non-hits.
#' @param iters Number of iterations to run the function for.
#' Recommended size: 10000L.
#' @param seed Seed.
#'
#' @return The AUC.
#'
#' @export
rs_fast_auc <- function(pos_scores, neg_scores, iters, seed) .Call(wrap__rs_fast_auc, pos_scores, neg_scores, iters, seed)

#' Create random AUCs
#'
#' @description This function creates a random set of AUCs based on a score
#' vector and a size of the positive set. This can be used for permutation-
#' based estimation of Z-scores and subsequently p-values.
#'
#' @param score_vec The overall vector of scores.
#' @param size_pos The size of the hits represented in the score_vec.
#' @param random_iters Number of random AUCs to generate.
#' @param auc_iters Number of random iterations to approximate the AUCs.
#' Recommended size: 10000L.
#' @param seed Seed.
#'
#' @return A vector of random AUCs based the score vector and size of the
#' positive set.
#'
#' @export
rs_create_random_aucs <- function(score_vec, size_pos, random_iters, auc_iters, seed) .Call(wrap__rs_create_random_aucs, score_vec, size_pos, random_iters, auc_iters, seed)

#' Calculate the Hedge's G effect
#'
#' @description Calculates the Hedge's G effect for two sets of matrices. The
#' function assumes that rows = samples and columns = features.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param mat_a The matrix of samples and features in grp A for which to
#' calculate the Hedge's G effect.
#' @param mat_b The matrix of samples and features in grp B for which to
#' calculate the Hedge's G effect.
#' @param small_sample_correction Shall the small sample correction be applied.
#'
#' @return Returns the harmonic sum according to the OT calculation.
#'
#' @export
rs_hedges_g <- function(mat_a, mat_b, small_sample_correction) .Call(wrap__rs_hedges_g, mat_a, mat_b, small_sample_correction)

#' Calculate a BH-based FDR
#'
#' @description Rust implementation that will be faster if you have an
#' terrifying amount of p-values to adjust.
#'
#' @param pvals Numeric vector. The p-values you wish to adjust.
#'
#' @return The Benjamini-Hochberg adjusted p-values.
#'
#' @export
rs_fdr_adjustment <- function(pvals) .Call(wrap__rs_fdr_adjustment, pvals)

#' Calculate the hypergeometric rest in Rust
#'
#' @param q Number of white balls drawn out of urn.
#' @param m Number of white balls in the urn.
#' @param n Number of black balls in the urn.
#' @param k The number of balls drawn out of the urn.
#'
#' @return P-value (with lower.tail set to False)
#'
#' @export
rs_phyper <- function(q, m, n, k) .Call(wrap__rs_phyper, q, m, n, k)

#' Calculate the critical value
#'
#' This function calculates the critical value for a given set based on random
#' permutations and a given alpha value.
#'
#' @param values Numeric vector. The full data set for which to calculate the
#' critical value.
#' @param iters Integer. Number of random permutations to use.
#' @param alpha Float. The alpha value. For example, 0.001 would mean that the
#' critical value is smaller than 0.1 percentile of the random permutations.
#' @param seed Integer. For reproducibility purposes
#'
#' @return The critical value for the given parameters.
#'
#' @export
rs_critval <- function(values, iters, alpha, seed) .Call(wrap__rs_critval, values, iters, alpha, seed)

#' Calculate the critical value
#'
#' This function calculates the critical value for a given set based on random
#' permutations and a given alpha value.
#'
#' @param mat Numeric matrix. The (symmetric matrix with all of the values).
#' @param iters Integer. Number of random permutations to use.
#' @param alpha Float. The alpha value. For example, 0.001 would mean that the
#' critical value is smaller than 0.1 percentile of the random permutations.
#' @param seed Integer. For reproducibility purposes
#'
#' @return The critical value for the given parameters.
#'
#' @export
rs_critval_mat <- function(mat, iters, alpha, seed) .Call(wrap__rs_critval_mat, mat, iters, alpha, seed)

#' Generate reciprocal best hits based on set similarities
#'
#' @description This function takes a nested list that contains gene modules/
#' sets derived from various methods and generate identifies reciprocal best
#' hits between gene modules/sets across the different origins. WARNING!
#' Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#'
#' @param module_list A nested named list. The outer list should contain the
#' origin of the gene modules, the inner list the names of the gene modules and
#' the respective genes in them.
#' @param overlap_coefficient Shall the overlap coefficient instead of the
#' Jaccard similarity be used.
#' @param min_similarity Minimum similarity that should exist between any two
#' given gene modules to actually calculate RBH pairs.
#' @param debug Boolean Boolean that activates print messages for debugging
#' purposes.
#'
#' @return A list containing:
#'  \itemize{
#'   \item origin - The name of the origin of the gene modules.
#'   \item target - The name of the target of the gene modules.
#'   \item comparisons - Integer vector indicating how many RBH hits were
#'   identified in this comparison
#'   \item origin_modules - Names of the gene modules from the origin.
#'   \item target_modules - Names of the gene modules from the target.
#'   \item similarity - The similarities between the two respective gene
#'   modules.
#' }
#' @export
rs_rbh_sets <- function(module_list, overlap_coefficient, min_similarity, debug) .Call(wrap__rs_rbh_sets, module_list, overlap_coefficient, min_similarity, debug)

#' Calculate the column-wise co-variance.
#'
#' @description Calculates the co-variance of the columns.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x R matrix with doubles.
#'
#' @returns The co-variance matrix.
#'
#' @export
rs_covariance <- function(x) .Call(wrap__rs_covariance, x)

#' Calculate the column wise correlations.
#'
#' @description Calculates the correlation matrix of the columns.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x R matrix with doubles.
#' @param spearman Shall the Spearman correlation be calculated instead of
#' Pearson.
#'
#' @returns The correlation matrix.
#'
#' @export
rs_cor <- function(x, spearman) .Call(wrap__rs_cor, x, spearman)

#' Calculates the correlation matrix from the co-variance matrix
#'
#' @description Calculates the correlation matrix from a co-variance
#' matrix
#'
#' @param x R matrix with doubles that is the co-variance matrix
#'
#' @returns The correlation matrix.
#'
#' @export
rs_cov2cor <- function(x) .Call(wrap__rs_cov2cor, x)

#' Rust implementation of prcomp
#'
#' @description Runs the singular value decomposition over the matrix x.
#' Assumes that samples = rows, and columns = features.
#'
#' @param x Numeric matrix. Rows = samples, columns = features.
#' @param scale Boolean. Shall the columns additionally be scaled.
#'
#' @return A list with:
#' \itemize{
#'   \item scores - The product of x (centred and potentially scaled) with v.
#'   \item v - v matrix of the SVD.
#'   \item s - Eigenvalues of the SVD.
#'   \item scaled - Boolean. Was the matrix scaled.
#' }
#'
#' @export
rs_prcomp <- function(x, scale) .Call(wrap__rs_prcomp, x, scale)

#' Run randomised SVD over a matrix
#'
#' @description Runs a randomised singular value decomposition over a matrix.
#' This implementation is faster than the full SVD on large data sets, with
#' slight loss in precision.
#'
#' @param x Numeric matrix. Rows = samples, columns = features.
#' @param rank Integer. The rank to use.
#' @param seed Integer. Random seed for reproducibility.
#' @param oversampling Integer. Defaults to `10L` if nothing is provided.
#' @param n_power_iter Integer. How often shall the QR decomposition be
#' applied. Defaults to `2L` if nothing is provided.
#'
#' @return A list with:
#' \itemize{
#'   \item u - u matrix of the SVD.
#'   \item v - v matrix of the SVD.
#'   \item s - Eigenvalues of the SVD.
#' }
#'
#' @export
rs_random_svd <- function(x, rank, seed, oversampling, n_power_iter) .Call(wrap__rs_random_svd, x, rank, seed, oversampling, n_power_iter)

#' Calculate the column wise correlations.
#'
#' @description Calculates the correlation matrix of the columns. This function
#' will return the upper triangle. WARNING! Incorrect use can cause kernel
#' crashes. Wrapper around the Rust functions with type checks are provided in
#' the package.
#'
#' @param x R matrix with doubles.
#' @param spearman Shall the Spearman correlation be calculated instead of
#' Pearson.
#' @param shift Shall a shift be applied to the matrix. 0 = the diagonal will
#' be included. 1 = the diagonal will not be included.
#'
#' @returns The upper triangle of the correlation matrix iterating through the
#' rows, shifted by one (the diagonal will not be returned).
#'
#' @export
rs_cor_upper_triangle <- function(x, spearman, shift) .Call(wrap__rs_cor_upper_triangle, x, spearman, shift)

#' Helper to identify the right epsilon parameter
#'
#' @description This function will take a distance vector from the upper
#' triangle of a symmetric distance matrix and apply the desired RBF with the
#' supplied epsilon from epsilon vec. Subsequently, the column sums will be
#' measured to identify the total similarity of each feature with other
#' features. This data can be used to see if the data follows scale-free
#' topology for example to identify the right epsilon parameter with the given
#' RBF.
#'
#' @param dist Numeric vector. The distances you wish to apply the RBF function
#' to.
#' @param epsilon_vec Numeric vector. The epsilons you wish to use/test.
#' @param original_dim Integer. The original dimensions of the symmetric
#' distance matrix.
#' @param shift Integer. Was the matrix shifted up (0 = diagonal included; 1
#' diagonal not incldued).
#' @param rbf_type String. Option of `c('gaussian', 'bump')` for the currently
#' implemented RBF function.
#'
#' @return A matrix with rows being the epsilons tested, and columns
#' representing the summed affinity to other features.
#'
#' @export
rs_rbf_iterate_epsilons <- function(dist, epsilon_vec, original_dim, shift, rbf_type) .Call(wrap__rs_rbf_iterate_epsilons, dist, epsilon_vec, original_dim, shift, rbf_type)

#' Calculate the column wise differential correlation between two sets of data.
#'
#' @description This function calculates the differential correlation based on
#' the Fisher method. For speed purposes, the function will only calculate the
#' differential correlation on the upper triangle of the two correlation
#' matrices.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x_a R matrix a to be used for the differential correlation analysis.
#' @param x_b R matrix a to be used for the differential correlation analysis.
#' @param spearman Shall the Spearman correlation be calculated instead of
#' Pearson.
#'
#' @return A list containing:
#'  \itemize{
#'   \item r_a - The correlation coefficients in the upper triangle of
#'   matrix a.
#'   \item r_b - The correlation coefficients in the upper triangle of
#'   matrix b.
#'   \item z_score - The z-scores of the difference in correlation
#'   coefficients.
#'   \item p_val - The z-scores transformed to p-values.
#' }
#'
#' @export
rs_differential_cor <- function(x_a, x_b, spearman) .Call(wrap__rs_differential_cor, x_a, x_b, spearman)

#' Calculate the contrastive PCA
#'
#' @description This function calculate the contrastive PCA given a target
#' covariance matrix and the background covariance matrix you wish to subtract.
#' The alpha parameter controls how much of the background covariance you wish
#' to remove. You have the options to return the feature loadings and you can
#' specificy the number of cPCAs to return. WARNING! Incorrect use can cause
#' kernel crashes. Wrapper around the Rust functions with type checks are
#' provided in the package.
#'
#' @param target_covar The co-variance matrix of the target data set.
#' @param background_covar The co-variance matrix of the background data set.
#' @param target_mat The original values of the target matrix.
#' @param alpha How much of the background co-variance should be removed.
#' @param n_pcs How many contrastive PCs to return
#' @param return_loadings Shall the loadings be returned from the contrastive
#' PCA
#'
#' @return A list containing:
#'  \itemize{
#'   \item factors - The factors of the contrastive PCA.
#'   \item loadings - The loadings of the contrastive PCA. Will be NULL if
#'    return_loadings is set to FALSE.
#' }
#'
#' @export
rs_contrastive_pca <- function(target_covar, background_covar, target_mat, alpha, n_pcs, return_loadings) .Call(wrap__rs_contrastive_pca, target_covar, background_covar, target_mat, alpha, n_pcs, return_loadings)

#' Reconstruct a matrix from a flattened upper triangle vector
#'
#' @description This function takes a flattened vector of the upper triangle
#' from a symmetric matrix (think correlation matrix) and reconstructs the full
#' dense matrix for you.
#'
#' @param cor_vector Numeric vector. The vector of correlation coefficients
#' that you want to use to go back to a dense matrix.
#' @param shift Integer. If you applied a shift, i.e. included the diagonal
#' values = 0; or excluded the diagonal values = 1.
#' @param n Integer. Original dimension (i.e., ncol/nrow) of the matrix to be
#' reconstructed.
#'
#' @return The dense R matrix.
#'
#' @export
rs_upper_triangle_to_dense <- function(cor_vector, shift, n) .Call(wrap__rs_upper_triangle_to_dense, cor_vector, shift, n)

#' Generate a vector-based representation of the upper triangle of a matrix
#'
#' @description This function generates a vector from the upper triangle of
#' a given symmetric matrix. You have the option to remove the diagonal with
#' setting shift to 1.
#'
#' @param x Numeric vector. The vector of correlation coefficients that you
#' want to use to go back to a dense matrix.
#' @param shift Integer. If you want to apply a shift, i.e. included the diagonal
#' values = 0; or excluded the diagonal values = 1.
#'
#' @return The dense R matrix.
#'
#' @export
rs_dense_to_upper_triangle <- function(x, shift) .Call(wrap__rs_dense_to_upper_triangle, x, shift)

#' Calculate the OT harmonic sum
#'
#' @param x The numeric vector (should be between 0 and 1) for which to
#' calculate the harmonic sum
#'
#' @return Returns the harmonic sum according to the OT calculation.
#'
#' @export
rs_ot_harmonic_sum <- function(x) .Call(wrap__rs_ot_harmonic_sum, x)

#' Apply a Radial Basis Function
#'
#' @description Applies a radial basis function (RBF) to a given distance
#' vector. Has at the option to apply a Gaussian, Bump or Inverse Quadratic
#' RBF.
#'
#' @param x Numeric vector. The distances you wish to apply the Gaussian kernel
#' onto.
#' @param epsilon Float. Epsilon parameter for the RBF.
#' @param rbf_type String. Needs to be from `c("gaussian", "bump", "inverse_quadratic")`.
#'
#' @return The affinities after the Kernel was applied.
#'
#' @export
rs_rbf_function <- function(x, epsilon, rbf_type) .Call(wrap__rs_rbf_function, x, epsilon, rbf_type)

#' Apply a Radial Basis Function (to a matrix)
#'
#' @description Applies a radial basis function (RBF) to a given distance
#' matrix. Has at the option to apply a Gaussian, Bump or Inverse Quadratic
#' RBF.
#'
#' @param x Numeric Matrix. The distances you wish to apply the Gaussian kernel
#' onto.
#' @param epsilon Float. Epsilon parameter for the RBF.
#' @param rbf_type String. Needs to be from `c("gaussian", "bump", "inverse_quadratic")`.
#'
#' @return The affinities after the Kernel was applied.
#'
#' @export
rs_rbf_function_mat <- function(x, epsilon, rbf_type) .Call(wrap__rs_rbf_function_mat, x, epsilon, rbf_type)

#' Apply a range normalisation on a vector.
#'
#' @description Applies a range normalisation on an R vector.
#'
#' @param x Numerical vector. The data to normalise.
#' @param max_val Numeric. The upper bound value to normalise into. If set to 1,
#' the function will be equal to a min-max normalisation.
#' @param min_val Numeric. The lower bound value to normalise into. If set to 0,
#' the function will equal a min-max normalisation.
#'
#' @return Normalised values
#'
#' @export
rs_range_norm <- function(x, max_val, min_val) .Call(wrap__rs_range_norm, x, max_val, min_val)

#' Prepare the data for whitening
#'
#' @description Prepares the data for subsequent usag in ICA.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x The matrix to whiten. The whitening will happen over the columns.
#' @param fast_svd Boolean. Shall a randomised SVD be used. This is way faster
#' on larger data sets.
#' @param seed Integer. Only relevant with fast_svd is set to `TRUE`.
#' @param rank Integer. How many ranks to use for the fast SVD approximation.
#' If you supply `NULL`, it will default to `10L`. Only relevant with
#' fast_svd is set to `TRUE`.
#' @param oversampling Integer. Oversampling parameter to make the approximation
#' more precise. If you supply `NULL`, it will default to `10L`. Only relevant
#' with fast_svd is set to `TRUE`.
#' @param n_power_iter Integer. How much shall the QR low rank approximation be
#' powered. If you supply `NULL`, it will default to `2L`.
#'
#'
#' @return A list containing:
#'  \itemize{
#'   \item x - The preprocessed matrix.
#'   \item k - The pre-whitening matrix k.
#' }
#'
#' @export
rs_prepare_whitening <- function(x, fast_svd, seed, rank, oversampling, n_power_iter) .Call(wrap__rs_prepare_whitening, x, fast_svd, seed, rank, oversampling, n_power_iter)

#' Run the Rust implementation of fast ICA.
#'
#' @description This function serves as a wrapper over the fast ICA
#' implementations in Rust. It assumes a whitened matrix and also an
#' intialised w_init. WARNING! Incorrect use can cause kernel crashes. Wrapper
#' around the Rust functions with type checks are provided in the package.
#'
#' @param whiten Numerical matrix. The whitened matrix.
#' @param w_init Numerical matrix. The initial unmixing matrix. ncols need to
#' be equal to nrows of whiten.
#' @param ica_type String. One of 'logcosh' or 'exp'.
#' @param ica_params A list containing:
#'  \itemize{
#'   \item maxit - Integer. Maximum number of iterations for ICA.
#'   \item alpha - Float. The alpha parameter for the logcosh version of ICA.
#'   Should be between 1 to 2.
#'   \item max_tol - Maximum tolerance of the algorithm
#'   \item verbose - Verbosity of the function, i.e., shall individual iters
#'   be shown.
#' }
#' If the list is empty or the expected elements are not found, default values
#' are used.
#'
#' @return A list with the following items:
#'  \itemize{
#'   \item mixing - The mixing matrix for subsequent usage.
#'   \item converged - Boolean if the algorithm converged.
#' }
#'
#' @export
rs_fast_ica <- function(whiten, w_init, ica_type, ica_params) .Call(wrap__rs_fast_ica, whiten, w_init, ica_type, ica_params)

#' Run ICA over a given no_comp with random initilisations of w_init
#'
#' @description This function implements a stabilised ICA like algorithm in
#' Rust. Briefly, it generates random w_init matrices (total number being
#' no_random_init) and runs ICA given the x_processed and k data over these.
#' The function returns combined S from the different runs and a boolean
#' vector indicating if this specific run converged.
#'
#' @param x1 Numerical matrix. The processed matrix (but not yet
#' whitened!)
#' @param k Numerical matrix. The whitening matrix.
#' @param no_comp Integer. Number of independent components to return.
#' @param no_random_init Integer. Number of random initialisations to test.
#' @param ica_type String. One of 'logcosh' or 'exp'.
#' @param random_seed Integer. Seed for randomisations.
#' @param ica_params A list containing:
#' \itemize{
#'   \item maxit - Integer. Maximum number of iterations for ICA.
#'   \item alpha - Float. The alpha parameter for the logcosh version of ICA.
#'   Should be between 1 to 2.
#'   \item max_tol - Maximum tolerance of the algorithm
#'   \item verbose - Verbosity of the function, i.e., shall individual iters
#'   be shown.
#' }
#' If the list is empty or the expected elements are not found, default values
#' are used.
#'
#' @return A list containing:
#' \itemize{
#'   \item s_combined - The combined matrices for S. Dimensions are nrows =
#'   features; and ncols = ncomp * no_random_init.
#'   \item converged - Boolean vector indicating if the respective run reached
#'   convergence. Length = no_random_init
#' }
#'
#' @export
rs_ica_iters <- function(x1, k, no_comp, no_random_init, ica_type, random_seed, ica_params) .Call(wrap__rs_ica_iters, x1, k, no_comp, no_random_init, ica_type, random_seed, ica_params)

#' Run ICA with cross-validation and random initialsiation
#'
#' @description This function will split the data into `no_folds` and apply
#' ICA with `no_random_inits` over that fold.
#'
#' @param x Numeric matrix. The processed data (no whitening function has
#' been applied yet.)
#' @param no_comp Integer. Number of components to test for.
#' @param no_random_init Integer. Number of random initialisations.
#' @param no_folds Integer. Number of folds to use for the cross-validation.
#' @param ica_type String. Which type of ICA shall be run.
#' @param random_seed Integer. For reproducibility.
#' @param ica_params A list containing:
#' \itemize{
#'   \item maxit - Integer. Maximum number of iterations for ICA.
#'   \item alpha - Float. The alpha parameter for the logcosh version of ICA.
#'   Should be between 1 to 2.
#'   \item max_tol - Maximum tolerance of the algorithm
#'   \item verbose - Verbosity of the function, i.e., shall individual iters
#'   be shown.
#' }
#' If the list is empty or the expected elements are not found, default values
#' are used.
#'
#' @return A list containing:
#' \itemize{
#'   \item s_combined - The combined matrices for S. Dimensions are nrows =
#'   features; and ncols = ncomp * no_random_init.
#'   \item converged - Boolean vector indicating if the respective run reached
#'   convergence. Length = no_random_init
#' }
#'
#' @export
rs_ica_iters_cv <- function(x, no_comp, no_folds, no_random_init, ica_type, random_seed, ica_params) .Call(wrap__rs_ica_iters_cv, x, no_comp, no_folds, no_random_init, ica_type, random_seed, ica_params)

#' Calculate the semantic similarity in an ontology
#'
#' @description This function calculates the specified semantic similarity and
#' returns the full vector (only calculating the upper triangle) for the given
#' similarity.
#'
#' @param terms Vector of strings. The terms in the ontology you wish to screen.
#' @param sim_type String. Must be one of `c("resnik", "lin", "combined")`.
#' @param ancestor_list R list with names being the term and the elements in the
#' list the names of the ancestors.
#' @param ic_list R list with the names being the term and the elements the
#' information content of this given term. Needs to be a single float!
#'
#' @return A vector containing all the desired similarity scores. This is
#' equivalent of the upper triangle of the similarity matrix.
#'
#' @export
rs_onto_semantic_sim <- function(terms, sim_type, ancestor_list, ic_list) .Call(wrap__rs_onto_semantic_sim, terms, sim_type, ancestor_list, ic_list)

#' Calculate the Wang similarity for an ontology
#'
#' @description This function calculates the Wang similarity for a given
#' ontology.
#'
#' @param parents String vector. The names of the parents.
#' @param children String vector. The names of the childs. The length of
#' `parents` needs to be equal to `children`.
#' @param w Float. The w parameter for the ontology. Needs to be between
#' `0 < w < 1`.
#' @param flat_matrix Boolean. Shall only the upper triangle be returned.
#'
#' @return A list with:
#' \itemize{
#'   \item sim_mat - the Wang similarity matrix.
#'   \item names - the row and column names for the calculated matrix.
#' }
#'
#' @export
rs_onto_sim_wang <- function(parents, children, w, flat_matrix) .Call(wrap__rs_onto_sim_wang, parents, children, w, flat_matrix)

#' Filter the term similarities for a specific critical value
#'
#' @description This function takes the similarity values as the upper triangle,
#' the row/column names and filtering the values down based on the threshold.
#'
#' @param sim_vals Numerical vector. The upper triangle of the similarity matrix
#' as a flattened vector.
#' @param names String vector. The row/col names of the similarity matrix.
#' @param threshold Float. The filtering threshold.
#'
#' @return A list with:
#' \itemize{
#'   \item t1 - name of term 1.
#'   \item t2 - name of term 2.
#'   \item sim - the similarity between the two terms.
#' }
#'
#' @export
rs_filter_onto_sim <- function(sim_vals, names, threshold) .Call(wrap__rs_filter_onto_sim, sim_vals, names, threshold)

#' Calculates the TOM over an affinity matrix
#'
#' @description Calculates the topological overlap measure for a given affinity matrix
#' x. Has the option to calculate the signed and unsigned version.
#'
#' @param x Numerical matrix. Affinity matrix.
#' @param tom_type String. One of `c("v1", "v2")` - pending on choice, a different
#' normalisation method will be used.
#' @param signed Boolean. Shall the signed TOM be calculated. If set to `FALSE`, values
#' should be ≥ 0.
#'
#' @return Returns the TOM matrix.
#'
#' @export
rs_tom <- function(x, tom_type, signed) .Call(wrap__rs_tom, x, tom_type, signed)

#' Helper function to assess CoReMo cluster quality
#'
#' @description This function assesses the quality of the clusters
#' with a given cut `k`. Returns the median R2 (cor^2) and the median absolute
#' deviation (MAD) of the clusters. Large clusters (≥1000) are subsampled
#' to a random set of 1000 genes.
#'
#' @param cluster_genes A list. Contains the cluster and their respective genes.
#' @param cor_mat Numerical matrix. Contains the correlation coefficients.
#' @param row_names String vector. The row names (or column names) of the
#' correlation matrix.
#' @param seed Integer. Random seed for the sub sampling of genes.
#'
#' @return A list containing:
#'  \itemize{
#'   \item r2med - median R2 of the cluster.
#'   \item r2mad - median absolute deviation of the R2 in the cluster.
#'   \item size - size of the cluster.
#' }
rs_coremo_quality <- function(cluster_genes, cor_mat, row_names, seed) .Call(wrap__rs_coremo_quality, cluster_genes, cor_mat, row_names, seed)

#' Helper function to assess CoReMo cluster stability
#'
#' @description This function is a helper for the leave-on-out stability
#' assessment of CoReMo clusters. The function will generate the distance
#' vectors based on leaving out the samples defined in indices one by one.
#'
#' @param data Numeric matrix. The original processed matrix.
#' @param indices Integer vector. The sample indices to remove to re-calculate
#' the distances.
#' @param epsilon Float. Epsilon parameter for the RBF.
#' @param rbf_type String. Needs to be from
#' `c("gaussian", "bump", "inverse_quadratic")`.
#' @param spearman Boolean. Shall Spearman correlation be used.
#'
#' @return A list with `length(indices)` elements, each containing the distance
#' minus the given sample.
rs_coremo_stability <- function(data, indices, epsilon, rbf_type, spearman) .Call(wrap__rs_coremo_stability, data, indices, epsilon, rbf_type, spearman)

#' Helper function to assess cluster stability
#'
#' @param data Integer matrix. Assumes that each column represents a given
#' resampling/bootstrap and the rows represent the features, while each integer
#' indicates cluster membership.
#'
#' @return A list containing:
#'  \itemize{
#'   \item mean_jaccard - mean Jaccard similarities for this feature across all
#'   the bootstraps, resamplings.
#'   \item std_jaccard - the standard deviation of the Jaccard similarities for
#'   this feature across all the bootstraps, resamplings.
#' }
rs_cluster_stability <- function(data) .Call(wrap__rs_cluster_stability, data)

#' @export
rs_upper_triangle_to_sparse <- function(cor_vector, shift, n) .Call(wrap__rs_upper_triangle_to_sparse, cor_vector, shift, n)


# nolint end
