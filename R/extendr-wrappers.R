# Generated by extendr: Do not edit by hand

# nolint start

#
# This file was created with the following call:
#   .Call("wrap__make_bixverse_wrappers", use_symbols = TRUE, package_name = "bixverse")

#' @usage NULL
#' @useDynLib bixverse, .registration = TRUE
NULL

#' @export
rs_calc_es_idx <- function(ranks, pathway_r) .Call(wrap__rs_calc_es_idx, ranks, pathway_r)

#' Helper function to rapidly retrieve the indices of the gene set members
#'
#' @param gene_universe Character Vector. The genes represented in the gene universe.
#' @param pathway_list List. A named list with each element containing the genes for this
#' pathway.
#'
#' @return Returns a list with the index positions of the gene set genes in the gene universe.
#'
#' @export
rs_get_gs_indices <- function(gene_universe, pathway_list) .Call(wrap__rs_get_gs_indices, gene_universe, pathway_list)

#' @export
rs_calc_es <- function(ranks, vec_name, pathway_r) .Call(wrap__rs_calc_es, ranks, vec_name, pathway_r)

#' @export
rs_gsea_traditional <- function(ranks, vec_name, iters, pathway_list, seed) .Call(wrap__rs_gsea_traditional, ranks, vec_name, iters, pathway_list, seed)

#' Rust implementation of the fgsea::calcGseaStat() function
#'
#' @param stats Numeric vector. The gene level statistic. Needs to
#' sorted in descending nature.
#' @param gs_idx Integer vector. The indices of the gene set genes.
#' @param gsea_param Float. The GSEA parameter. Usually defaults to 1.0.
#' @param return_leading_edge Boolean. Return the leading edge indices.
#'
#' @return List with the following elements
#' \itemize{
#'     \item gene_stat Enrichment score for that gene set
#'     \item leading_edge Indicies of the leading edge genes.
#' }
#'
#' @export
rs_calc_gsea_stats <- function(stats, gs_idx, gsea_param, return_leading_edge) .Call(wrap__rs_calc_gsea_stats, stats, gs_idx, gsea_param, return_leading_edge)

#' @export
rs_calc_gsea_stat_cumulative <- function(stats, gs_indices, gsea_param) .Call(wrap__rs_calc_gsea_stat_cumulative, stats, gs_indices, gsea_param)

#' @export
rs_calc_gsea_stat_cumulative_batch <- function(stats, pathway_scores, pathway_sizes, iters, gsea_param, seed) .Call(wrap__rs_calc_gsea_stat_cumulative_batch, stats, pathway_scores, pathway_sizes, iters, gsea_param, seed)

#' Run a single hypergeometric test.
#'
#' @description Given a set of target genes, this is a Rust implementation of
#' an hypergeometric test testing for overenrichment of the target genes in the
#' gene sets. WARNING! Incorrect use can cause kernel crashes. Wrapper around
#' the Rust functions with type checks are provided in the package.
#'
#' @param target_genes A character vector representing the target gene set.
#' @param gene_sets A list of strings that represent the gene sets to test against.
#' @param gene_universe A character vector representing the gene universe from
#' which the target genes and gene sets are sampled from.
#'
#' @return A list containing:
#'  \itemize{
#'   \item pvals - The p-values from the hypergeometric test
#'   \item odds_ratios - The calculated odds ratios
#'   \item overlap - The size of the overlap
#'   \item gene_set_lengths - The length of the gene sets.
#' }
#'
#' @export
rs_hypergeom_test <- function(target_genes, gene_sets, gene_universe) .Call(wrap__rs_hypergeom_test, target_genes, gene_sets, gene_universe)

#' Run a hypergeometric test over a list of target genes
#'
#' @description Given a list of target gene sets, this function will test for
#' each of the individual target genes the hypergeoemetric enrichment against
#' the specified gene sets. WARNING! Incorrect use can cause kernel crashes.
#' Wrapper around the Rust functions with type checks are provided in the
#' package.
#'
#' @param target_genes_list A character vector representing the target gene set.
#' @param gene_sets A list of strings that represent the gene sets to test
#' against.
#' @param gene_universe A character vector representing the gene universe from
#' which the target genes and gene sets are sampled from.
#'
#' @return A list containing:
#'  \itemize{
#'   \item pvals - The p-values from the hypergeometric test
#'   \item odds ratios - The calculated odds ratios
#'   \item overlap - The size of the overlap
#'   \item gene_set_lengths - The length of the gene sets.
#' }
#'
#' @export
rs_hypergeom_test_list <- function(target_genes_list, gene_sets, gene_universe) .Call(wrap__rs_hypergeom_test_list, target_genes_list, gene_sets, gene_universe)

#' Run hypergeometric enrichment over the gene ontology
#'
#' @description This function implements a Rust version of the gene ontology
#' enrichment with elimination: the starting point are the leafs of the
#' ontology and hypergeometric tests will first conducted there. Should the
#' hypergeometric test p-value be below a certain threshold, the genes of that
#' gene ontology term will be removed from all ancestors. WARNING! Incorrect
#' use can cause kernel crashes. Wrapper around the Rust functions with type
#' checks are provided in the package.
#'
#' @param target_genes A character vector representing the target gene set.
#' @param levels A character vector representing the levels to iterate through.
#' The order will be the one the iterations are happening in.
#' @param go_obj The gene_ontology_data S7 class. See [bixverse::gene_ontology_data()].
#' @param gene_universe_length The length of the gene universe.
#' @param min_genes number of minimum genes for the gene ontology term to be
#' tested.
#' @param elim_threshold p-value below which the elimination procedure shall be
#' applied to the ancestors.
#' @param debug boolean that will provide additional console information for
#' debugging purposes.
#'
#' @return A list containing:
#'  \itemize{
#'   \item go_ids - The gene ontology identifier.
#'   \item pvals - The calculated odds ratios.
#'   \item odds_ratios - The calculated odds ratios.
#'   \item overlap - The size of the overlap.
#'   \item gene_set_lengths - The length of the gene sets.
#' }
#'
#' @export
rs_gse_geom_elim <- function(target_genes, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug) .Call(wrap__rs_gse_geom_elim, target_genes, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug)

#' Run hypergeometric enrichment a list of target genes over the gene ontology
#'
#' This function implements a Rust version of the gene ontology enrichment with
#' elimination: the starting point are the leafs of the ontology and
#' hypergeometric tests will first conducted there. Should the hypergeometric
#' test p-value be below a certain threshold, the genes of that gene ontology
#' term will be removed from all ancestors. This function is designed to
#' leverage Rust-based threading for parallel processing of a list of target
#' genes. WARNING! Incorrect use can cause kernel crashes. Wrapper around the
#' Rust functions with type checks are provided in the package.
#'
#' @param target_genes_list A list of target genes against which to run the
#' method.
#' @param levels A character vector representing the levels to iterate through.
#' The order will be the one the iterations are happening in.
#' @param go_obj The gene_ontology_data S7 class. See [bixverse::gene_ontology_data()].
#' @param gene_universe_length The length of the gene universe.
#' @param min_genes number of minimum genes for the gene ontology term to be
#' tested.
#' @param elim_threshold p-value below which the elimination procedure shall
#' be applied to the ancestors.
#' @param debug boolean that will provide additional console information for
#' debugging purposes.
#'
#' @return A list containing:
#'  \itemize{
#'   \item go_ids - The gene ontology identifier.
#'   \item pvals - The calculated odds ratios.
#'   \item odds_ratios - The calculated odds ratios.
#'   \item overlap - The size of the overlap.
#'   \item gene_set_lengths - The length of the gene sets.
#'   \item no_test - The number of tests that were conducted against
#'   target_gene_list. First element indicates how many values belong to the
#'   first target_genes set in the list, etc.
#' }
#'
#' @export
rs_gse_geom_elim_list <- function(target_genes_list, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug) .Call(wrap__rs_gse_geom_elim_list, target_genes_list, levels, go_obj, gene_universe_length, min_genes, elim_threshold, debug)

#' Set similarities over list
#'
#' This function calculates the Jaccard or similarity index between a one given
#' string vector and list of vectors.
#'
#' @param s_1_list The String vector against which to calculate the set similarities.
#' @param s_2_list A List of vector against which to calculate the set similarities.
#' @param overlap_coefficient Boolean. Use the overlap coefficient instead of the Jaccard similarity be calculated.
#'
#' @export
rs_set_similarity_list <- function(s_1_list, s_2_list, overlap_coefficient) .Call(wrap__rs_set_similarity_list, s_1_list, s_2_list, overlap_coefficient)

#' Set similarities
#'
#' This function calculates the Jaccard or similarity index between a two given
#' string vector and a  of other string vectors.
#'
#' @param s_1 The String vector against which to calculate the set similarities.
#' @param s_2 The String vector against which to calculate the set similarities.
#' @param overlap_coefficient Boolean. Use the overlap coefficient instead of the Jaccard similarity be calculated.
#'
#' @export
rs_set_similarity <- function(s_1, s_2, overlap_coefficient) .Call(wrap__rs_set_similarity, s_1, s_2, overlap_coefficient)

#' Fast AUC calculation
#'
#' @description This function calculates rapidly AUCs based on an approximation.
#'
#' @param pos_scores The scores of your hits.
#' @param neg_scores The scores of your non-hits.
#' @param iters Number of iterations to run the function for.
#' Recommended size: 10000L.
#' @param seed Seed.
#'
#' @return The AUC.
#'
#' @export
rs_fast_auc <- function(pos_scores, neg_scores, iters, seed) .Call(wrap__rs_fast_auc, pos_scores, neg_scores, iters, seed)

#' Create random AUCs
#'
#' @description This function creates a random set of AUCs based on a score
#' vector and a size of the positive set. This can be used for permutation-
#' based estimation of Z-scores and subsequently p-values.
#'
#' @param score_vec The overall vector of scores.
#' @param size_pos The size of the hits represented in the score_vec.
#' @param random_iters Number of random AUCs to generate.
#' @param auc_iters Number of random iterations to approximate the AUCs.
#' Recommended size: 10000L.
#' @param seed Seed.
#'
#' @return A vector of random AUCs based the score vector and size of the
#' positive set.
#'
#' @export
rs_create_random_aucs <- function(score_vec, size_pos, random_iters, auc_iters, seed) .Call(wrap__rs_create_random_aucs, score_vec, size_pos, random_iters, auc_iters, seed)

#' Calculate the Hedge's G effect
#'
#' @description Calculates the Hedge's G effect for two sets of matrices. The
#' function assumes that rows = samples and columns = features.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param mat_a The matrix of samples and features in grp A for which to
#' calculate the Hedge's G effect.
#' @param mat_b The matrix of samples and features in grp B for which to
#' calculate the Hedge's G effect.
#' @param small_sample_correction Shall the small sample correction be applied.
#'
#' @return Returns the harmonic sum according to the OT calculation.
#'
#' @export
rs_hedges_g <- function(mat_a, mat_b, small_sample_correction) .Call(wrap__rs_hedges_g, mat_a, mat_b, small_sample_correction)

#' Calculate a BH-based FDR
#'
#' @description Rust implementation that will be faster if you have an
#' terrifying amount of p-values to adjust.
#'
#' @param pvals Numeric vector. The p-values you wish to adjust.
#'
#' @return The Benjamini-Hochberg adjusted p-values.
#'
#' @export
rs_fdr_adjustment <- function(pvals) .Call(wrap__rs_fdr_adjustment, pvals)

#' Calculate the hypergeometric rest in Rust
#'
#' @param q Number of white balls drawn out of urn.
#' @param m Number of white balls in the urn.
#' @param n Number of black balls in the urn.
#' @param k The number of balls drawn out of the urn.
#'
#' @return P-value (with lower.tail set to False)
#'
#' @export
rs_phyper <- function(q, m, n, k) .Call(wrap__rs_phyper, q, m, n, k)

#' Generate reciprocal best hits based on set similarities
#'
#' @description This function takes a nested list that contains gene modules/
#' sets derived from various methods and generate identifies reciprocal best
#' hits between gene modules/sets across the different origins. WARNING!
#' Incorrect use can cause kernel crashes. Wrapper around the Rust functions
#' with type checks are provided in the package.
#'
#' @param module_list A nested named list. The outer list should contain the
#' origin of the gene modules, the inner list the names of the gene modules and
#' the respective genes in them.
#' @param overlap_coefficient Shall the overlap coefficient instead of the
#' Jaccard similarity be used.
#' @param min_similarity Minimum similarity that should exist between any two
#' given gene modules to actually calculate RBH pairs.
#' @param debug Boolean Boolean that activates print messages for debugging
#' purposes.
#'
#' @return A list containing:
#'  \itemize{
#'   \item origin - The name of the origin of the gene modules.
#'   \item target - The name of the target of the gene modules.
#'   \item comparisons - Integer vector indicating how many RBH hits were
#'   identified in this comparison
#'   \item origin_modules - Names of the gene modules from the origin.
#'   \item target_modules - Names of the gene modules from the target.
#'   \item similarity - The similarities between the two respective gene
#'   modules.
#' }
#' @export
rs_rbh_sets <- function(module_list, overlap_coefficient, min_similarity, debug) .Call(wrap__rs_rbh_sets, module_list, overlap_coefficient, min_similarity, debug)

#' Calculate the column-wise co-variance.
#'
#' @description Calculates the co-variance of the columns.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x R matrix with doubles.
#'
#' @returns The co-variance matrix.
#'
#' @export
rs_covariance <- function(x) .Call(wrap__rs_covariance, x)

#' Calculate the column wise correlations.
#'
#' @description Calculates the correlation matrix of the columns.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x R matrix with doubles.
#' @param spearman Shall the Spearman correlation be calculated instead of
#' Pearson.
#'
#' @returns The correlation matrix.
#'
#' @export
rs_cor <- function(x, spearman) .Call(wrap__rs_cor, x, spearman)

#' Rust implementation of prcomp
#'
#' @description Runs the singular value decomposition over the matrix x.
#' Assumes that samples = rows, and columns = features.
#'
#' @param x Numeric matrix. Rows = samples, columns = features.
#' @param scale Boolean. Shall the columns additionally be scaled.
#'
#' @return A list with:
#' \itemize{
#'   \item scores - The product of x (centred and potentially scaled) with v.
#'   \item v - v matrix of the SVD.
#'   \item s - Eigenvalues of the SVD.
#'   \item scaled - Boolean. Was the matrix scaled.
#' }
#'
#' @export
rs_prcomp <- function(x, scale) .Call(wrap__rs_prcomp, x, scale)

#' Run randomised SVD over a matrix
#'
#' @description Runs a randomised singular value decomposition over a matrix.
#' This implementation is faster than the full SVD on large data sets, with
#' slight loss in precision.
#'
#' @param x Numeric matrix. Rows = samples, columns = features.
#' @param rank Integer. The rank to use.
#' @param seed Integer. Random seed for reproducibility.
#' @param oversampling Integer. Defaults to `10L` if nothing is provided.
#' @param n_power_iter Integer. How often shall the QR decomposition be
#' applied. Defaults to `2L` if nothing is provided.
#'
#' @return A list with:
#' \itemize{
#'   \item u - u matrix of the SVD.
#'   \item v - v matrix of the SVD.
#'   \item s - Eigenvalues of the SVD.
#' }
#'
#' @export
rs_random_svd <- function(x, rank, seed, oversampling, n_power_iter) .Call(wrap__rs_random_svd, x, rank, seed, oversampling, n_power_iter)

#' Calculate the column wise correlations.
#'
#' @description Calculates the correlation matrix of the columns. This function
#' will return the upper triangle. WARNING! Incorrect use can cause kernel
#' crashes. Wrapper around the Rust functions with type checks are provided in
#' the package.
#'
#' @param x R matrix with doubles.
#' @param spearman Shall the Spearman correlation be calculated instead of
#' Pearson.
#' @param shift Shall a shift be applied to the matrix. 0 = the diagonal will
#' be included. 1 = the diagonal will not be included.
#'
#' @returns The upper triangle of the correlation matrix iterating through the
#' rows, shifted by one (the diagonal will not be returned).
#'
#' @export
rs_cor_upper_triangle <- function(x, spearman, shift) .Call(wrap__rs_cor_upper_triangle, x, spearman, shift)

#' Helper to identify the right epsilon parameter
#'
#' @description This function will take a distance vector from the upper
#' triangle of a symmetric distance matrix and apply the desired RBF with the
#' supplied epsilon from epsilon vec. Subsequently, the column sums will be
#' measured to identify the total similarity of each feature with other
#' features. This data can be used to see if the data follows scale-free
#' topology for example to identify the right epsilon parameter with the given
#' RBF.
#'
#' @param dist Numeric vector. The distances you wish to apply the RBF function
#' to.
#' @param epsilon_vec Numeric vector. The epsilons you wish to use/test.
#' @param original_dim Integer. The original dimensions of the symmetric
#' distance matrix.
#' @param shift Integer. Was the matrix shifted up (0 = diagonal included; 1
#' diagonal not incldued).
#' @param rbf_type String. Option of `c('gaussian', 'bump')` for the currently
#' implemented RBF function.
#'
#' @return A matrix with rows being the epsilons tested, and columns
#' representing the summed affinity to other features.
#'
#' @export
rs_rbf_iterate_epsilons <- function(dist, epsilon_vec, original_dim, shift, rbf_type) .Call(wrap__rs_rbf_iterate_epsilons, dist, epsilon_vec, original_dim, shift, rbf_type)

#' Calculate the column wise differential correlation between two sets of data.
#'
#' @description This function calculates the differential correlation based on
#' the Fisher method. For speed purposes, the function will only calculate the
#' differential correlation on the upper triangle of the two correlation
#' matrices.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x_a R matrix a to be used for the differential correlation analysis.
#' @param x_b R matrix a to be used for the differential correlation analysis.
#' @param spearman Shall the Spearman correlation be calculated instead of
#' Pearson.
#'
#' @return A list containing:
#'  \itemize{
#'   \item r_a - The correlation coefficients in the upper triangle of
#'   matrix a.
#'   \item r_b - The correlation coefficients in the upper triangle of
#'   matrix b.
#'   \item z_score - The z-scores of the difference in correlation
#'   coefficients.
#'   \item p_val - The z-scores transformed to p-values.
#' }
#'
#' @export
rs_differential_cor <- function(x_a, x_b, spearman) .Call(wrap__rs_differential_cor, x_a, x_b, spearman)

#' Calculate the contrastive PCA
#'
#' @description This function calculate the contrastive PCA given a target
#' covariance matrix and the background covariance matrix you wish to subtract.
#' The alpha parameter controls how much of the background covariance you wish
#' to remove. You have the options to return the feature loadings and you can
#' specificy the number of cPCAs to return. WARNING! Incorrect use can cause
#' kernel crashes. Wrapper around the Rust functions with type checks are
#' provided in the package.
#'
#' @param target_covar The co-variance matrix of the target data set.
#' @param background_covar The co-variance matrix of the background data set.
#' @param target_mat The original values of the target matrix.
#' @param alpha How much of the background co-variance should be removed.
#' @param n_pcs How many contrastive PCs to return
#' @param return_loadings Shall the loadings be returned from the contrastive
#' PCA
#'
#' @return A list containing:
#'  \itemize{
#'   \item factors - The factors of the contrastive PCA.
#'   \item loadings - The loadings of the contrastive PCA. Will be NULL if
#'    return_loadings is set to FALSE.
#' }
#'
#' @export
rs_contrastive_pca <- function(target_covar, background_covar, target_mat, alpha, n_pcs, return_loadings) .Call(wrap__rs_contrastive_pca, target_covar, background_covar, target_mat, alpha, n_pcs, return_loadings)

#' Reconstruct a matrix from a flattened upper triangle vector
#'
#' @description This function takes a flattened vector of the upper triangle
#' from a symmetric matrix (think correlation matrix) and reconstructs the full
#' dense matrix for you.
#'
#' @param cor_vector Numeric vector. The vector of correlation coefficients
#' that you want to use to go back to a dense matrix.
#' @param shift Integer. If you applied a shift, i.e. included the diagonal
#' values = 0; or excluded the diagonal values = 1.
#' @param n Integer. Original dimension (i.e., ncol/nrow) of the matrix to be
#' reconstructed.
#'
#' @return The dense R matrix.
#'
#' @export
rs_upper_triangle_to_dense <- function(cor_vector, shift, n) .Call(wrap__rs_upper_triangle_to_dense, cor_vector, shift, n)

#' Calculate the OT harmonic sum
#'
#' @param x The numeric vector (should be between 0 and 1) for which to
#' calculate the harmonic sum
#'
#' @return Returns the harmonic sum according to the OT calculation.
#'
#' @export
rs_ot_harmonic_sum <- function(x) .Call(wrap__rs_ot_harmonic_sum, x)

#' Apply a Radial Basis Function
#'
#' @description Applies a radial basis function (RBF) to a given distance
#' vector. Has at the moment a Gaussian version and a Bump version.
#'
#' @param x Numeric vector. The distances you wish to apply the Gaussian kernel
#' onto.
#' @param epsilon Float. Epsilon parameter for the RBF.
#' @param rbf_type String. Needs to be from `c("gaussian", "bump)`.
#'
#' @return The affinities after the Kernel was applied.
#'
#' @export
rs_rbf_function <- function(x, epsilon, rbf_type) .Call(wrap__rs_rbf_function, x, epsilon, rbf_type)

#' Apply a range normalisation on a vector.
#'
#' @description Applies a range normalisation on an R vector.
#'
#' @param x Numerical vector. The data to normalise.
#' @param max_val Numeric. The upper bound value to normalise into. If set to 1,
#' the function will be equal to a min-max normalisation.
#' @param min_val Numeric. The lower bound value to normalise into. If set to 0,
#' the function will equal a min-max normalisation.
#'
#' @return Normalised values
#'
#' @export
rs_range_norm <- function(x, max_val, min_val) .Call(wrap__rs_range_norm, x, max_val, min_val)

#' Prepare the data for whitening
#'
#' @description Prepares the data for subsequent usag in ICA.
#' WARNING! Incorrect use can cause kernel crashes. Wrapper around the Rust
#' functions with type checks are provided in the package.
#'
#' @param x The matrix to whiten. The whitening will happen over the columns.
#' @param fast_svd Boolean. Shall a randomised SVD be used. This is way faster
#' on larger data sets.
#' @param seed Integer. Only relevant with fast_svd is set to `TRUE`.
#' @param rank Integer. How many ranks to use for the fast SVD approximation.
#' If you supply `NULL`, it will default to `10L`. Only relevant with
#' fast_svd is set to `TRUE`.
#' @param oversampling Integer. Oversampling parameter to make the approximation
#' more precise. If you supply `NULL`, it will default to `10L`. Only relevant
#' with fast_svd is set to `TRUE`.
#' @param n_power_iter Integer. How much shall the QR low rank approximation be
#' powered. If you supply `NULL`, it will default to `2L`.
#'
#'
#' @return A list containing:
#'  \itemize{
#'   \item x - The preprocessed matrix.
#'   \item k - The pre-whitening matrix k.
#' }
#'
#' @export
rs_prepare_whitening <- function(x, fast_svd, seed, rank, oversampling, n_power_iter) .Call(wrap__rs_prepare_whitening, x, fast_svd, seed, rank, oversampling, n_power_iter)

#' Run the Rust implementation of fast ICA.
#'
#' @description This function serves as a wrapper over the fast ICA
#' implementations in Rust. It assumes a whitened matrix and also an
#' intialised w_init. WARNING! Incorrect use can cause kernel crashes. Wrapper
#' around the Rust functions with type checks are provided in the package.
#'
#' @param whiten Numerical matrix. The whitened matrix.
#' @param w_init Numerical matrix. The initial unmixing matrix. ncols need to
#' be equal to nrows of whiten.
#' @param ica_type String. One of 'logcosh' or 'exp'.
#' @param ica_params A list containing:
#'  \itemize{
#'   \item maxit - Integer. Maximum number of iterations for ICA.
#'   \item alpha - Float. The alpha parameter for the logcosh version of ICA.
#'   Should be between 1 to 2.
#'   \item max_tol - Maximum tolerance of the algorithm
#'   \item verbose - Verbosity of the function, i.e., shall individual iters
#'   be shown.
#' }
#' If the list is empty or the expected elements are not found, default values
#' are used.
#'
#' @return A list with the following items:
#'  \itemize{
#'   \item mixing - The mixing matrix for subsequent usage.
#'   \item converged - Boolean if the algorithm converged.
#' }
#'
#' @export
rs_fast_ica <- function(whiten, w_init, ica_type, ica_params) .Call(wrap__rs_fast_ica, whiten, w_init, ica_type, ica_params)

#' Run ICA over a given no_comp with random initilisations of w_init
#'
#' @description This function implements a stabilised ICA like algorithm in
#' Rust. Briefly, it generates random w_init matrices (total number being
#' no_random_init) and runs ICA given the x_processed and k data over these.
#' The function returns combined S from the different runs and a boolean
#' vector indicating if this specific run converged.
#'
#' @param x1 Numerical matrix. The processed matrix (but not yet
#' whitened!)
#' @param k Numerical matrix. The whitening matrix.
#' @param no_comp Integer. Number of independent components to return.
#' @param no_random_init Integer. Number of random initialisations to test.
#' @param ica_type String. One of 'logcosh' or 'exp'.
#' @param random_seed Integer. Seed for randomisations.
#' @param ica_params A list containing:
#' \itemize{
#'   \item maxit - Integer. Maximum number of iterations for ICA.
#'   \item alpha - Float. The alpha parameter for the logcosh version of ICA.
#'   Should be between 1 to 2.
#'   \item max_tol - Maximum tolerance of the algorithm
#'   \item verbose - Verbosity of the function, i.e., shall individual iters
#'   be shown.
#' }
#' If the list is empty or the expected elements are not found, default values
#' are used.
#'
#' @return A list containing:
#' \itemize{
#'   \item s_combined - The combined matrices for S. Dimensions are nrows =
#'   features; and ncols = ncomp * no_random_init.
#'   \item converged - Boolean vector indicating if the respective run reached
#'   convergence. Length = no_random_init
#' }
#'
#' @export
rs_ica_iters <- function(x1, k, no_comp, no_random_init, ica_type, random_seed, ica_params) .Call(wrap__rs_ica_iters, x1, k, no_comp, no_random_init, ica_type, random_seed, ica_params)

#' Run ICA with cross-validation and random initialsiation
#'
#' @description This function will split the data into `no_folds` and apply
#' ICA with `no_random_inits` over that fold.
#'
#' @param x Numeric matrix. The processed data (no whitening function has
#' been applied yet.)
#' @param no_comp Integer. Number of components to test for.
#' @param no_random_init Integer. Number of random initialisations.
#' @param no_folds Integer. Number of folds to use for the cross-validation.
#' @param ica_type String. Which type of ICA shall be run.
#' @param random_seed Integer. For reproducibility.
#' @param ica_params A list containing:
#' \itemize{
#'   \item maxit - Integer. Maximum number of iterations for ICA.
#'   \item alpha - Float. The alpha parameter for the logcosh version of ICA.
#'   Should be between 1 to 2.
#'   \item max_tol - Maximum tolerance of the algorithm
#'   \item verbose - Verbosity of the function, i.e., shall individual iters
#'   be shown.
#' }
#' If the list is empty or the expected elements are not found, default values
#' are used.
#'
#' @return A list containing:
#' \itemize{
#'   \item s_combined - The combined matrices for S. Dimensions are nrows =
#'   features; and ncols = ncomp * no_random_init.
#'   \item converged - Boolean vector indicating if the respective run reached
#'   convergence. Length = no_random_init
#' }
#'
#' @export
rs_ica_iters_cv <- function(x, no_comp, no_folds, no_random_init, ica_type, random_seed, ica_params) .Call(wrap__rs_ica_iters_cv, x, no_comp, no_folds, no_random_init, ica_type, random_seed, ica_params)

#' Calculate the semantic similarity in an ontology
#'
#' @description This function calculates the specified semantic similarity and
#' returns the full vector (only calculating the upper triangle) for the given
#' similarity.
#'
#' @param terms Vector of strings. The terms in the ontology you wish to screen.
#' @param sim_type String. Must be one of `c("resnik", "lin", "combined")`.
#' @param ancestor_list R list with names being the term and the elements in the
#' list the names of the ancestors.
#' @param ic_list R list with the names being the term and the elements the
#' information content of this given term. Needs to be a single float!
#'
#' @return A vector containing all the desired similarity scores. This is
#' equivalent of the upper triangle of the similarity matrix.
#'
#' @export
rs_onto_similarity <- function(terms, sim_type, ancestor_list, ic_list) .Call(wrap__rs_onto_similarity, terms, sim_type, ancestor_list, ic_list)

#' Calculate the semantic similarity in an ontology
#'
#' @description This function calculates the specified semantic similarity and
#' returns the full vector (only calculating the upper triangle) for the given
#' similarity.
#'
#' @param terms Vector of strings. The terms in the ontology you wish to screen.
#' @param sim_type String. Must be one of `c("resnik", "lin", "combined")`.
#' @param alpha Float. Must be between 0 to 1. The alpha parameter for calculating
#' the critival value.
#' @param ancestor_list R list with names being the term and the elements in the
#' list the names of the ancestors.
#' @param ic_list R list with the names being the term and the elements the
#' information content of this given term. Needs to be a single float!
#' @param iters Integer. Number of random iterations to use to estimate the
#' critical value.
#' @param seed Integer. Random seed for reproducibility purposes.
#'
#' @return A list with:
#' \itemize{
#'   \item term1 - Term 1
#'   \item v - v matrix of the SVD.
#'   \item s - Eigenvalues of the SVD.
#' }
#'
#' @export
rs_onto_similarity_filtered <- function(terms, sim_type, alpha, ancestor_list, ic_list, iters, seed) .Call(wrap__rs_onto_similarity_filtered, terms, sim_type, alpha, ancestor_list, ic_list, iters, seed)


# nolint end
