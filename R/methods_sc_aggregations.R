# single cell aggregation methods ----------------------------------------------

## meta cells ------------------------------------------------------------------

### hdwgcna method -------------------------------------------------------------

#' Generate meta cells based on hdWGCNA and return a `meta_cells` object
#'
#' @description
#' This function implements the meta cell aggregation from Morabito, et al.
#' The generation of metacells is a useful approach for subsequent application
#' of for example correlation-based methods to identify co-regulated genes.
#'
#' @param object `single_cell_exp` class.
#' @param sc_meta_cell_params List. Output of [bixverse::params_sc_metacells()].
#' A list with the following items:
#' \itemize{
#'   \item max_shared - Maximum number of allowed shared neighbours for
#'   the meta cell to be considered.
#'   \item target_no_metacells - Number of target meta cells you wish to reach.
#'   \item max_iter - Maximum number of iterations you want to use for the
#'   algorithm.
#'   \item k - Number of neighbours for the kNN search. Only relevant if you
#'   set regenerate_knn to `TRUE`.
#'   \item knn_method - String. Which kNN algorithm to use. One of
#'   `c("annoy", "hnsw", "nndescent")`. Defaults to `"annoy"`. Only relevant if
#'   you set regenerate_knn to `TRUE`.
#'   \item ann_dist - String. Distance metric for the approximate neighbour
#'   search. One of `c("cosine", "euclidean")`. Defaults to `"cosine"`. Only
#'   relevant if you set regenerate_knn to `TRUE`.
#'   \item n_trees - Integer. Number of trees to use for the annoy algorithm.
#'   Only relevant if you set regenerate_knn to `TRUE`.
#'   \item search_budget - Integer. Search budget per tree for the annoy
#'   algorithm. Only relevant if you set regenerate_knn to `TRUE`.
#'   \item nn_max_iter - Integer. Maximum iterations for NN Descent. Only
#'   relevant if you set regenerate_knn to `TRUE` and use
#'   `"nndescent"`.
#'   \item rho - Numeric. Sampling rate for NN Descent. Only relevant if you
#'   set regenerate_knn to `TRUE` and use `"nndescent"`.
#'   \item delta - Numeric. Early termination criterion for NN Descent. Only
#'   relevant if you set regenerate_knn to `TRUE` and use `"nndescent"`.
#' }
#' @param regenerate_knn Boolean. Shall a kNN graph be regenerated.
#' @param embd_to_use String. The embedding to use. Only relevant if you set
#' regenerate_knn to `TRUE`.
#' @param no_embd_to_use Optional integer. Number of embedding dimensions to
#' use. If `NULL` all will be used. Only relevant if you set regenerate_knn to
#' `TRUE`.
#' @param cells_to_use Optional string. Names of the cells to use for the
#' generation of the meta-cells. If provided, this function will regenerate the
#' kNN graph no matter what.
#' @param target_size Numeric. The library target size to normalise the meta
#' cells to.
#' @param seed Integer. Seed for reproducibility.
#' @param .verbose Boolean. Controls verbosity of the function.
#'
#' @returns A [bixverse::meta_cells()] with the data generated by this meta cell
#' aggregation method.
#'
#' @export
#'
#' @references
#' Morabito, et al. Cell Rep Methods, 2023
get_meta_cells_sc <- S7::new_generic(
  name = "get_meta_cells_sc",
  dispatch_args = "object",
  fun = function(
    object,
    sc_meta_cell_params = params_sc_metacells(),
    regenerate_knn = FALSE,
    embd_to_use = "pca",
    no_embd_to_use = NULL,
    cells_to_use = NULL,
    target_size = 1e5,
    seed = 42L,
    .verbose = TRUE
  ) {
    S7::S7_dispatch()
  }
)

#' @method get_meta_cells_sc single_cell_exp
#'
#' @export
#'
#' @importFrom zeallot `%<-%`
#' @importFrom magrittr `%>%`
S7::method(get_meta_cells_sc, single_cell_exp) <- function(
  object,
  sc_meta_cell_params = params_sc_metacells(),
  regenerate_knn = FALSE,
  embd_to_use = "pca",
  no_embd_to_use = NULL,
  cells_to_use = NULL,
  target_size = 1e5,
  seed = 42L,
  .verbose = TRUE
) {
  # checks
  checkmate::assertClass(object, "bixverse::single_cell_exp")
  assertScMetacells(sc_meta_cell_params)
  checkmate::qassert(regenerate_knn, "B1")
  checkmate::qassert(embd_to_use, "S1")
  checkmate::qassert(no_embd_to_use, c("I1", "0"))
  checkmate::qassert(cells_to_use, c("S+", "0"))
  checkmate::qassert(target_size, "N1")
  checkmate::qassert(.verbose, "B1")

  # if the kNN graph shall be regenerated, get the emedding here...
  if (regenerate_knn) {
    embd <- get_embedding(x = object, embd_name = embd_to_use)

    # early return
    if (is.null(embd)) {
      warning(
        paste(
          "The desired embedding was not found. Please check the parameters.",
          "Returning NULL."
        )
      )

      return(NULL)
    }

    if (!is.null(no_embd_to_use)) {
      to_take <- min(c(no_embd_to_use, ncol(embd)))
      embd <- embd[, 1:to_take]
    }
    knn_data <- NULL
  } else {
    embd <- NULL
    knn_data <- get_knn_mat(object)

    if (is.null(knn_data)) {
      warning(
        paste(
          "No kNN data could be found on the object. Set regenerate_knn to",
          "TRUE or generate the kNN matrix via other means",
          "Returning NULL."
        )
      )
      return(NULL)
    }
  }

  if (!is.null(cells_to_use)) {
    cells_to_use <- get_cell_indices(
      object,
      cell_ids = cells_to_use,
      rust_index = TRUE
    )

    embd <- get_embedding(x = object, embd_name = embd_to_use)

    # early return
    if (is.null(embd)) {
      warning(
        paste(
          "The desired embedding was not found. Please check the parameters.",
          "Returning NULL."
        )
      )

      return(NULL)
    }

    if (!is.null(no_embd_to_use)) {
      to_take <- min(c(no_embd_to_use, ncol(embd)))
      embd <- embd[, 1:to_take]
    }
    knn_data <- NULL
  }

  meta_cell_data <- rs_get_metacells(
    f_path = get_rust_count_cell_f_path(object),
    knn_mat = knn_data,
    embd = embd,
    cells_to_use = cells_to_use,
    cells_to_keep = get_cells_to_keep(object),
    meta_cell_params = sc_meta_cell_params,
    target_size = target_size,
    seed = seed,
    verbose = .verbose
  )

  var_data <- get_sc_var(object, cols = c("gene_idx", "gene_id"))

  meta_cell_obj <- meta_cells(
    meta_cell_data = meta_cell_data,
    var_data = var_data,
    meta_cell_method = "meta_cells_hdwgcna"
  )

  return(meta_cell_obj)
}

### seacells -------------------------------------------------------------------

#' Generate meta cells based on SEACells and return a `meta_cells` object
#'
#' @description
#' This function implements the meta cell aggregation from Persad et al., and
#' returns the resuling SEACells. Compared to other algorithms, a kernel
#' archetype analysis is used to identify the metacells. For details, please
#' refer to the publication.
#'
#' @param object `single_cell_exp` class.
#' @param seacell_params List. Output of [bixverse::params_sc_seacells()].
#' A list with the following items:
#' \itemize{
#'   \item n_sea_cells - Number of SEA cells to detect.
#'   \item max_fw_iters - Maximum iterations for the Franke-Wolfe algorithm per
#'   matrix update.
#'   \item convergence_epsilon - Convergence threshold. Algorithm stops when
#'   RSS change < epsilon * RSS(0).
#'   \item max_iter - Maximum iterations to run SEACells for.
#'   \item min_iter - Minimum iterations to run SEACells for.
#'   \item greedy_threshold - Maximum number of cells before defaulting to rapid
#'   random selection of archetypes.
#'   \item graph_building - Graph building method.
#'   \item k - Number of neighbours for the kNN algorithm.
#'   \item knn_method - String. Which kNN algorithm to use. One of
#'   `c("annoy", "hnsw", "nndescent")`. Defaults to `"annoy"`.
#'   \item n_trees - Integer. Number of trees to use for the annoy algorithm.
#'   \item search_budget - Integer. Search budget during querying for the annoy
#'   algorithm.
#'   \item nn_max_iter - Integer. Maximum iterations for NN Descent. Only
#'   relevant if you use `"nndescent"`.
#'   \item rho - Numeric. Sampling rate for NN Descent. Only relevant if you
#'   use `"nndescent"`.
#'   \item delta - Numeric. Early termination criterion for NN Descent. Only
#'   relevant if you use `"nndescent"`.
#' }
#' @param embd_to_use String. The embedding to use. Atm, the only option is
#' `"pca"`. Only relevant if you set regenerate_knn to `TRUE`.
#' @param no_embd_to_use Optional integer. Number of embedding dimensions to
#' use. If `NULL` all will be used. Only relevant if you set regenerate_knn to
#' `TRUE`.
#' @param cells_to_use Optional string. Names of the cells to use for the
#' generation of the SEACells.
#' @param target_size Numeric. The library target size to normalise the meta
#' cells to.
#' @param seed Integer. Seed for reproducibility.
#' @param .verbose Boolean. Controls verbosity of the function.
#'
#' @returns A [bixverse::meta_cells()] with the data generated by this meta cell
#' aggregation method.
#'
#' @export
#'
#' @references
#' Morabito, et al. Cell Rep Methods, 2023
get_seacells_sc <- S7::new_generic(
  name = "get_seacells_sc",
  dispatch_args = "object",
  fun = function(
    object,
    seacell_params = params_sc_seacells(),
    embd_to_use = "pca",
    no_embd_to_use = NULL,
    cells_to_use = NULL,
    target_size = 1e5,
    seed = 42L,
    .verbose = TRUE
  ) {
    S7::S7_dispatch()
  }
)

#' @method get_seacells_sc single_cell_exp
#'
#' @export
#'
#' @importFrom zeallot `%<-%`
#' @importFrom magrittr `%>%`
S7::method(get_seacells_sc, single_cell_exp) <- function(
  object,
  seacell_params = params_sc_seacells(),
  embd_to_use = "pca",
  no_embd_to_use = NULL,
  cells_to_use = NULL,
  target_size = 1e5,
  seed = 42L,
  .verbose = TRUE
) {
  # checks
  checkmate::assertClass(object, "bixverse::single_cell_exp")
  assertScSeacells(seacell_params)
  checkmate::qassert(embd_to_use, "S1")
  checkmate::qassert(no_embd_to_use, c("I1", "0"))
  checkmate::qassert(target_size, "N1")
  checkmate::qassert(.verbose, "B1")

  # function body
  embd <- get_embedding(x = object, embd_name = embd_to_use)

  if (!is.null(no_embd_to_use)) {
    to_take <- min(c(no_embd_to_use, ncol(embd)))
    embd <- embd[, 1:to_take]
  }

  if (!is.null(cells_to_use)) {
    cells_to_use <- get_cell_indices(
      object,
      cell_ids = cells_to_use,
      rust_index = TRUE
    )
  }

  seacell_data <- rs_get_seacells(
    f_path = get_rust_count_cell_f_path(object),
    embd = embd,
    cells_to_use = cells_to_use,
    cells_to_keep = get_cells_to_keep(object),
    seacells_params = seacell_params,
    target_size = target_size,
    seed = seed,
    verbose = .verbose
  )

  var_data <- get_sc_var(object, cols = c("gene_idx", "gene_id"))

  meta_cell_obj <- meta_cells(
    meta_cell_data = seacell_data,
    var_data = var_data,
    meta_cell_method = "seacell"
  )

  return(meta_cell_obj)
}

### supercells -----------------------------------------------------------------

#' Generate SuperCells and return a `meta_cells` object
#'
#' @description
#' This function implements the meta cell aggregation from Bilous, et al.
#' The core idea is to use the walktrap community detection on the kNN graph.
#' For details, please refer to the paper.
#'
#' @param object `single_cell_exp` class.
#' @param sc_supercell_params List. Output of [bixverse::params_sc_supercell()].
#' A list with the following items:
#' \itemize{
#'   \item walk_length - Integer. Walk length for the Walktrap algorithm.
#'   \item graining_factor - Numeric. Graining level of data (proportion of
#'   number of single cells in the initial dataset to the number of metacells in
#'   the final dataset)
#'   \item linkage_dist - String. Which type of distance metric to use for the
#'   linkage. Defaults to `"complete"`.
#'   \item k - Number of neighbours for the kNN search. Only relevant if you
#'   set regenerate_knn to `TRUE`.
#'   \item knn_method - String. Which kNN algorithm to use. One of
#'   `c("annoy", "hnsw", "nndescent")`. Defaults to `"annoy"`. Only relevant if
#'   you set regenerate_knn to `TRUE`.
#'   \item ann_dist - String. Distance metric for the approximate neighbour
#'   search. One of `c("cosine", "euclidean")`. Defaults to `"cosine"`. Only
#'   relevant if you set regenerate_knn to `TRUE`.
#'   \item n_trees - Integer. Number of trees to use for the annoy algorithm.
#'   Only relevant if you set regenerate_knn to `TRUE`.
#'   \item search_budget - Integer. Search budget per tree for the annoy
#'   algorithm. Only relevant if you set regenerate_knn to `TRUE`.
#'   \item nn_max_iter - Integer. Maximum iterations for NN Descent. Only
#'   relevant if you set regenerate_knn to `TRUE` and use
#'   `"nndescent"`.
#'   \item rho - Numeric. Sampling rate for NN Descent. Only relevant if you
#'   set regenerate_knn to `TRUE` and use `"nndescent"`.
#'   \item delta - Numeric. Early termination criterion for NN Descent. Only
#'   relevant if you set regenerate_knn to `TRUE` and use `"nndescent"`.
#' }
#' @param regenerate_knn Boolean. Shall a kNN graph be regenerated.
#' @param embd_to_use String. The embedding to use. Only relevant if you set
#' regenerate_knn to `TRUE`.
#' @param no_embd_to_use Optional integer. Number of embedding dimensions to
#' use. If `NULL` all will be used. Only relevant if you set regenerate_knn to
#' `TRUE`.
#' @param cells_to_use Optional string. Names of the cells to use for the
#' generation of the meta-cells. If provided, this function will regenerate the
#' kNN graph no matter what.
#' @param target_size Numeric. The library target size to normalise the meta
#' cells to.
#' @param seed Integer. Seed for reproducibility.
#' @param .verbose Boolean. Controls verbosity of the function.
#'
#' @returns A [bixverse::meta_cells()] with the data generated by this meta cell
#' aggregation method.
#'
#' @export
#'
#' @references
#' Bilous, et al. BMC Bioinform., 2022
get_supercells_sc <- S7::new_generic(
  name = "get_supercells_sc",
  dispatch_args = "object",
  fun = function(
    object,
    sc_supercell_params = params_sc_supercell(),
    regenerate_knn = FALSE,
    embd_to_use = "pca",
    no_embd_to_use = NULL,
    cells_to_use = NULL,
    target_size = 1e5,
    seed = 42L,
    .verbose = TRUE
  ) {
    S7::S7_dispatch()
  }
)

#' @method get_supercells_sc single_cell_exp
#'
#' @export
S7::method(get_supercells_sc, single_cell_exp) <- function(
  object,
  sc_supercell_params = params_sc_supercell(),
  regenerate_knn = FALSE,
  embd_to_use = "pca",
  no_embd_to_use = NULL,
  cells_to_use = NULL,
  target_size = 1e5,
  seed = 42L,
  .verbose = TRUE
) {
  # checks
  checkmate::assertClass(object, "bixverse::single_cell_exp")
  assertScSupercell(sc_supercell_params)
  checkmate::qassert(regenerate_knn, "B1")
  checkmate::qassert(embd_to_use, "S1")
  checkmate::qassert(no_embd_to_use, c("I1", "0"))
  checkmate::qassert(cells_to_use, c("S+", "0"))
  checkmate::qassert(target_size, "N1")
  checkmate::qassert(.verbose, "B1")

  # if the kNN graph shall be regenerated, get the embedding here...
  if (regenerate_knn) {
    embd <- get_embedding(x = object, embd_name = embd_to_use)

    # early return
    if (is.null(embd)) {
      warning(
        paste(
          "The desired embedding was not found. Please check the parameters.",
          "Returning NULL."
        )
      )

      return(NULL)
    }

    if (!is.null(no_embd_to_use)) {
      to_take <- min(c(no_embd_to_use, ncol(embd)))
      embd <- embd[, 1:to_take]
    }
    knn_data <- NULL
  } else {
    embd <- NULL
    knn_data <- get_knn_mat(object)

    if (is.null(knn_data)) {
      warning(
        paste(
          "No kNN data could be found on the object. Set regenerate_knn to",
          "TRUE or generate the kNN matrix via other means",
          "Returning NULL."
        )
      )
      return(NULL)
    }
  }

  if (!is.null(cells_to_use)) {
    cells_to_use <- get_cell_indices(
      object,
      cell_ids = cells_to_use,
      rust_index = TRUE
    )

    embd <- get_embedding(x = object, embd_name = embd_to_use)

    # early return
    if (is.null(embd)) {
      warning(
        paste(
          "The desired embedding was not found. Please check the parameters.",
          "Returning NULL."
        )
      )

      return(NULL)
    }

    if (!is.null(no_embd_to_use)) {
      to_take <- min(c(no_embd_to_use, ncol(embd)))
      embd <- embd[, 1:to_take]
    }
    knn_data <- NULL
  }

  supercell_res <- rs_supercell(
    f_path = get_rust_count_cell_f_path(object),
    knn_mat = knn_data,
    embd = embd,
    cells_to_use = cells_to_use,
    cells_to_keep = get_cells_to_keep(object),
    supercell_params = sc_supercell_params,
    target_size = target_size,
    seed = seed,
    verbose = .verbose
  )

  var_data <- get_sc_var(object, cols = c("gene_idx", "gene_id"))

  meta_cell_obj <- meta_cells(
    meta_cell_data = supercell_res,
    var_data = var_data,
    meta_cell_method = "supercells"
  )

  return(meta_cell_obj)
}
