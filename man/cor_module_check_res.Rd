% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cor_methods.R
\name{cor_module_check_res}
\alias{cor_module_check_res}
\title{Identify correlation-based gene modules via graphs.}
\usage{
cor_module_check_res(
  bulk_coexp,
  min_res = 0.1,
  max_res = 10,
  number_res = 15L,
  random_seed = 123L,
  kernel_bandwidth = 0.2,
  min_affinity = 0.001,
  min_genes = 10L,
  parallel = TRUE,
  max_workers = as.integer(parallel::detectCores()/2),
  .verbose = TRUE
)
}
\arguments{
\item{min_res}{Numeric. The minimum resolution to test for the Leiden
community detection.}

\item{max_res}{Numeric. The maximum resolution to test for the Leiden
community detection.}

\item{number_res}{Integer. Number of resolutions to test.
The resolutions will be spread in a logarithmic fashion over \code{min_res} to
\code{max_res}.}

\item{random_seed}{Integer. Random seed.}

\item{kernel_bandwidth}{Numeric. !This parameter is only relevant for simple
correlation modules!. The bandwidth for the affinity kernel. Needs to be
value between 0 and 1.}

\item{min_affinity}{Float. !This parameter is only relevant for simple
correlation modules! This parameter will remove edges below this affinity
threshold. Needs to be a value between 0 and 1.}

\item{min_genes}{Integer. Minimum number of genes that should be in a
community.}

\item{parallel}{Boolean. Parallelise the Leiden clustering.}

\item{max_workers}{Integer. Maximum number of workers to use if parallel is
set to \code{TRUE}.}

\item{.verbose}{Controls the verbosity of the function.}

\item{`bulk_coexp`}{The class, see \code{\link[=bulk_coexp]{bulk_coexp()}}.}
}
\description{
This function will identify gene modules based on affinity graphs from the
single correlation or differential correlation methods. Briefly, in the case
of single correlation, the graph is generated based on the absolute
correlation coefficients that are subjected to a Gaussian affinity kernel.
TODO: Write what is being done for differential correlation methods.
This reduces spurious correlations and leaves a sparsely connected graph.
Subsequently, Leiden community detection is applied through a range of
resolutions that the user can define. The function then returns meta
information about the resolutions (which can also be plotted) to identify
the best suitable resolution parameter to identify co-expression modules.
}
