% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods_single_cell_processing.R
\name{find_neigbours_single_cell}
\alias{find_neigbours_single_cell}
\title{Find the neighbours for single cell.}
\usage{
find_neigbours_single_cell(
  object,
  embd_to_use = "pca",
  no_embd_to_use = NULL,
  neighbours_params = params_sc_neighbours(),
  seed = 42L,
  .verbose = TRUE
)
}
\arguments{
\item{object}{\code{single_cell_exp} class.}

\item{embd_to_use}{String. The embedding to use. Atm, the only option is
\code{"pca"}.}

\item{no_embd_to_use}{Optional integer. Number of embedding dimensions to
use. If \code{NULL} all will be used.}

\item{neighbours_params}{List. Output of \code{\link[=params_sc_neighbours]{params_sc_neighbours()}}.
A list with the following items:
\itemize{
\item k - Integer. Number of neighbours to identify.
\item n_trees -  Integer. Number of trees to use for the \code{annoy} algorithm.
The higher, the longer the algorithm takes, but the more precise the
approximated nearest neighbours.
\item search_budget - Integer. Search budget per tree for the \code{annoy}
algorithm. The higher, the longer the algorithm takes, but the more precise
the approximated nearest neighbours.
\item knn_algorithm - String. One of \code{c("annoy", "hnsw")}. \code{"hnsw"} takes
longer, is more precise and more memory friendly. \code{"annoy"} is faster, less
precise and will take more memory.
\item full_snn - Boolean. Shall the sNN graph be generated across all
cells (standard in the \code{bluster} package.) Defaults to \code{FALSE}.
\item pruning - Value below which the weight in the sNN graph is set to 0.
\item snn_similarity - String. One of \code{c("rank", "jaccard")}. Defines how
the weight is calculated. For details, please see
\code{\link[=params_sc_neighbours]{params_sc_neighbours()}}.
}}

\item{seed}{Integer. For reproducibility.}

\item{.verbose}{Boolean. Controls verbosity and returns run times.}
}
\value{
The object with added KNN matrix.
}
\description{
This function will generate the kNNs based on a given embedding (atm,
only option is PCA). Two different algorithms are implemented with different
speed and accuracy to approximate the nearest neighbours. \code{"annoy"} is more
rapid and based on the \verb{Approximate Nearest Neigbours Oh Yeah} algorithm,
whereas \code{"hnsw"} implements a \verb{Hierarchical Navigatable Small Worlds} vector
search that is slower, but more precise. Subsequently, the kNN data will
be used to generate an sNN igraph for clustering methods.
}
