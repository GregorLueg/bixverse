% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods_sc_processing.R
\name{find_neighbours_sc}
\alias{find_neighbours_sc}
\title{Find the neighbours for single cell.}
\usage{
find_neighbours_sc(
  object,
  embd_to_use = "pca",
  no_embd_to_use = NULL,
  neighbours_params = params_sc_neighbours(),
  seed = 42L,
  .verbose = TRUE
)
}
\arguments{
\item{object}{\code{single_cell_exp} class.}

\item{embd_to_use}{String. The embedding to use. Whichever you chose, it
needs to be part of the object.}

\item{no_embd_to_use}{Optional integer. Number of embedding dimensions to
use. If \code{NULL} all will be used. If the number here is higher than the
found number of features in the embedding matrix, it defaults to the maximum
number of features.}

\item{neighbours_params}{List. Output of \code{\link[=params_sc_neighbours]{params_sc_neighbours()}}.
A list with the following items:
\itemize{
\item k - Integer. Number of neighbours to identify.
\item knn_algorithm - String. One of \code{c("annoy", "hnsw", "nndescent")}.
\code{"hnsw"} takes longer, is more precise and more memory friendly. \code{"annoy"}
is faster, less precise and will take more memory. \code{"nndescent"} skips
index generation and can be faster on small datasets.
\item n_trees -  Integer. Number of trees to use for the \code{annoy} algorithm.
The higher, the longer the algorithm takes, but the more precise the
approximated nearest neighbours.
\item search_budget - Integer. Search budget per tree for the \code{annoy}
algorithm. The higher, the longer the algorithm takes, but the more precise
the approximated nearest neighbours.
\item ann_dist - String. One of \code{c("cosine", "euclidean")}.
\item max_iter - Integer. Maximum iterations for the \code{"nndescent"} method.
\item rho - Numeric. Sampling rate for the \code{"nndescent"} method.
\item delta - Numeric. Early termination criterium for the \code{"nndescent"}
method.
\item full_snn - Boolean. Shall the sNN graph be generated across all
cells (standard in the \code{bluster} package.) Defaults to \code{FALSE}.
\item pruning - Value below which the weight in the sNN graph is set to 0.
\item snn_similarity - String. One of \code{c("rank", "jaccard")}. Defines how
the weight form the SNN graph is calculated. For details, please see
\code{\link[=params_sc_neighbours]{params_sc_neighbours()}}.
}}

\item{seed}{Integer. For reproducibility.}

\item{.verbose}{Boolean. Controls verbosity and returns run times.}
}
\value{
The object with added KNN matrix.
}
\description{
This function will generate the kNNs based on a given embedding. Three
different algorithms are implemented with different speed and accuracy to
approximate the nearest neighbours. \code{"annoy"} is more
rapid and based on the \verb{Approximate Nearest Neigbours Oh Yeah} algorithm;
\code{"hnsw"} implements a \verb{Hierarchical Navigatable Small Worlds} vector
search that is slower, but more precise. Lastly, there is the option of
\code{"nndescent"}, a Rust-based implementation of the PyNNDescent algorithm. This
version skips the index generation and can be faster on smaller data sets.
Subsequently, the kNN data will be used to generate an sNN igraph for
clustering methods.
}
\details{
The function will be executed on the cells that are defined by
\code{\link[=set_cells_to_keep]{set_cells_to_keep()}}. If you have not set this parameter, all
cells in the object will be initially used. The information which cells
were used for the calculation of the kNN matrix and sNN graph will be
additionally stored.
}
