% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods_sc_processing.R
\name{generate_knn_sc}
\alias{generate_knn_sc}
\title{Generate the KNN data with distances}
\usage{
generate_knn_sc(
  object,
  embd_to_use = "pca",
  cells_to_use = NULL,
  no_embd_to_use = NULL,
  neighbours_params = params_sc_neighbours(),
  seed = 42L,
  .verbose = TRUE
)
}
\arguments{
\item{object}{\code{single_cell_exp} class.}

\item{embd_to_use}{String. The embedding to use. Whichever you chose, it
needs to be part of the object.}

\item{cells_to_use}{String. Optional cell names to include in the generation
of the kNN graph. If \code{NULL} all (filtered) cells in the object will be used.}

\item{no_embd_to_use}{Optional integer. Number of embedding dimensions to
use. If \code{NULL} all will be used.}

\item{neighbours_params}{List. Output of \code{\link[=params_sc_neighbours]{params_sc_neighbours()}}.
A list with the following items:
\itemize{
\item k - Integer. Number of neighbours to identify.
\item knn_algorithm - String. One of \code{c("annoy", "hnsw", "nndescent")}.
\code{"hnsw"} takes longer, is more precise and more memory friendly. \code{"annoy"}
is faster, less precise and will take more memory. \code{"nndescent"} skips
index generation and can be faster on small datasets.
\item n_trees -  Integer. Number of trees to use for the \code{annoy} algorithm.
The higher, the longer the algorithm takes, but the more precise the
approximated nearest neighbours.
\item search_budget - Integer. Search budget per tree for the \code{annoy}
algorithm. The higher, the longer the algorithm takes, but the more precise
the approximated nearest neighbours.
\item ann_dist - String. One of \code{c("cosine", "euclidean")}.
\item max_iter - Integer. Maximum iterations for the \code{"nndescent"} method.
\item rho - Numeric. Sampling rate for the \code{"nndescent"} method.
\item delta - Numeric. Early termination criterium for the \code{"nndescent"}
method.
\item full_snn - Boolean. Shall the sNN graph be generated across all
cells (standard in the \code{bluster} package.) Defaults to \code{FALSE}. Not
relevant for this function.
\item pruning - Value below which the weight in the sNN graph is set to 0.
Not relevant for this function.
\item snn_similarity - String. One of \code{c("rank", "jaccard")}. Defines how
the weight form the SNN graph is calculated. For details, please see
\code{\link[=params_sc_neighbours]{params_sc_neighbours()}}. Not relevant for this function.
}}

\item{seed}{Integer. For reproducibility.}

\item{.verbose}{Boolean. Controls verbosity and returns run times.}
}
\value{
Initialised \code{sc_knn} with the kNN data and the distances added.
}
\description{
This function will generate the kNNs based on a given embedding. Three
different algorithms are implemented with different speed and accuracy to
approximate the nearest neighbours. \code{"annoy"} is more
rapid and based on the \verb{Approximate Nearest Neigbours Oh Yeah} algorithm;
\code{"hnsw"} implements a \verb{Hierarchical Navigatable Small Worlds} vector
search that is slower, but more precise. Lastly, there is the option of
\code{"nndescent"}, a Rust-based implementation of the PyNNDescent algorithm. This
version skips the index generation and can be faster on smaller data sets.
This version of the function returns an \code{sc_knn} object that can be
used in other functions.
}
\details{
This class does not have yet other methods, but these will be aded in the
future.
}
