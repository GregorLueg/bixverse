% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/param_wrappers.R
\name{params_sc_neighbours}
\alias{params_sc_neighbours}
\title{Wrapper function for parameters for neighbour identification in single cell}
\usage{
params_sc_neighbours(
  k = 15L,
  n_trees = 100L,
  search_budget = 100L,
  knn_algorithm = c("annoy", "hnsw"),
  ann_dist = c("cosine", "euclidean"),
  full_snn = FALSE,
  pruning = 1/15,
  snn_similarity = c("rank", "jaccard")
)
}
\arguments{
\item{k}{Integer. Number of neighbours to return.}

\item{n_trees}{Integer. Number of trees to use for the \code{annoy} algorithm.}

\item{search_budget}{Integer. Search budget per tree for the \code{annoy}
algorithm.}

\item{knn_algorithm}{String. One of \code{c("annoy", "hnsw")}. Defaults to
\code{"annoy"}.}

\item{ann_dist}{String. One of \code{c("cosine", "euclidean")}. The distance
metric to be used for the approximate neighbour search.}

\item{full_snn}{Boolean. Shall the full shared nearest neighbour graph
be generated that generates edges between all cells instead of between
only neighbours.}

\item{pruning}{Numeric. Weights below this threshold will be set to 0 in
the generation of the sNN graph.}

\item{snn_similarity}{String. One of \code{c("rank", "jaccard")}. The Jaccard
similarity calculates the Jaccard between the neighbours, whereas the rank
method calculates edge weights based on the ranking of shared neighbours.
For the rank method, the weight is determined by finding the shared
neighbour with the lowest combined rank across both cells, where
lower-ranked (closer) shared neighbors result in higher edge weights
Both methods produce weights normalised to the range \verb{[0, 1]}.}
}
\value{
A list with the neighbour parameters.
}
\description{
Wrapper function for parameters for neighbour identification in single cell
}
