% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extendr-wrappers.R
\name{rs_ica_iters}
\alias{rs_ica_iters}
\title{Run ICA over a given no_comp with random initilisations of w_init}
\usage{
rs_ica_iters(
  x_processed,
  k,
  no_comp,
  no_random_init,
  ica_type,
  random_seed,
  ica_params
)
}
\arguments{
\item{x_processed}{Numerical matrix. The processed matrix (but not yet
whitened!)}

\item{k}{Numerical matrix. The whitening matrix.}

\item{no_comp}{Integer. Number of independent components to return.}

\item{no_random_init}{Integer. Number of random initialisations to test.}

\item{ica_type}{String. One of 'logcosh' or 'exp'.}

\item{random_seed}{Integer. Seed for randomisations.}

\item{ica_params}{A list containing:
\itemize{
\item maxit - Integer. Maximum number of iterations for ICA.
\item alpha - Float. The alpha parameter for the logcosh version of ICA.
Should be between 1 to 2.
\item max_tol - Maximum tolerance of the algorithm
\item verbose - Verbosity of the function, i.e., shall individual iters
be shown.
}
If the list is empty or the expected elements are not found, default values
are used.}
}
\value{
A list containing:
\itemize{
\item s_combined - The combined matrices for S. Dimensions are nrows =
features; and ncols = ncomp * no_random_init.
\item converged - Boolean vector indicating if the respective run reached
convergence. Length = no_random_init
}
}
\description{
This function implements a stabilised ICA like algorithm in
Rust. Briefly, it generates random w_init matrices (total number being
no_random_init) and runs ICA given the x_processed and k data over these.
The function returns combined S from the different runs and a boolean
vector indicating if this specific run converged.
}
