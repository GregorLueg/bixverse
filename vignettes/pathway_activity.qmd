---
title: "Pathway activity functions"
vignette: >
  %\VignetteIndexEntry{Pathway activity functions}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

## Single sample pathway activity functions

An often used algorithm to check pathway activity (or maybe rather concordant
up or down-regulation of genes belonging to a given pathway) is 
[GSVA](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-7).
There is a corresponding package on 
[BioConductor](https://www.bioconductor.org/packages/release/bioc/html/GSVA.html) for this, but `bixverse` offers Rust-accelerated versions of two of the
algorithm. 

```{r}
#| label: setup
library(bixverse)
```

### Data

Similar to the vignette of GSVA, let us create some random data (Gaussian or
Poisson distributed) to mimic different types of transcriptomics measurements.

```{r}
#| label: random data generation

p <- 10000 # number of genes
n <- 100   # number of samples
  
# simulate expression values from a standard Gaussian distribution
X <- matrix(
  rnorm(p * n),
  nrow = p,
  dimnames = list(paste0("g", 1:p), paste0("s", 1:n))
)

# simulate expression values from a Poisson distribution
X1 <- matrix(
  rpois(p * n, lambda = 10),
  nrow = p,
  dimnames = list(paste0("g", 1:p), paste0("s", 1:n))
)
storage.mode(X1) <- "numeric"

# generate some random gene sets
gs <- as.list(sample(10:100, size = 250, replace = TRUE))
# sample gene sets
gs <- lapply(
  gs,
  function(n, p) paste0("g", sample(1:p, size = n, replace = FALSE)),
  p
)
names(gs) <- paste0("gs", 1:length(gs))
```

### GSVA (Gaussian version)

To run the GSVA implementation in bixverse, you can just do

```{r}
#| label: bixverse GSVA (Gaussian kernel)

bixverse_res_gaussian <- calc_gsva(
  exp = X,
  pathways = gs,
  gaussian = TRUE
)

bixverse_res_gaussian[1:5, 1:5]
```

If we compare against the original implementation of GSVA

```{r}
#| label: original GSVA (Gaussian kernel)
#| eval: !expr requireNamespace("GSVA", quietly = TRUE)

library(GSVA)

gsvaPar <- gsvaParam(X, gs)

gsva_res_gaussian <- as.matrix(
  gsva(gsvaPar, verbose=FALSE)
)

gsva_res_gaussian[1:5, 1:5]
```

We can appreciated very similar values. There is slight differences in
numerical precision due to optimisations in Rust. However, the correlations
between the two are â‰¥0.99

```{r}
#| label: correlations between GSVA and bixverse
#| eval: !expr requireNamespace("GSVA", quietly = TRUE)

correlations <- diag(
  cor(bixverse_res_gaussian, gsva_res_gaussian)
)

same_res <- all(correlations >= 0.99)

print(
  paste(
    "GSVA and bixverse return (basically) the",
    sprintf("same results for GSVA (Gaussian): %s", same_res)
  )
)
```

The `biverse` code is highly optimised, hence, usually yielding faster
results compared to the original `GSVA` code.

```{r}
#| label: speed comparison
#| eval: !expr requireNamespace(c("GSVA", "microbenchmark"), quietly = TRUE)

microbenchmark::microbenchmark(
  gsva = {
    gsvaPar <- gsvaParam(X, gs)
    gsva(gsvaPar, verbose = FALSE)
  },
  bixverse = calc_gsva(
    exp = X,
    pathways = gs,
    gaussian = TRUE
  ),
  times = 10L
)
```

### GSVA (Poisson version)

To use the version with a Poisson kernel (more appropriate for count data) is
as simple. 

```{r}
#| label: bixverse GSVA (Poisson kernel)

# bixverse expects floats also for the Poisson version
storage.mode(X1) <- "numeric"

bixverse_res_poisson <- calc_gsva(
  exp = X1,
  pathways = gs,
  gaussian = FALSE # uses the Poisson kernel now
)

bixverse_res_poisson[1:5, 1:5]
```

This is how you would do this in the official GSVA code:

```{r}
#| label: original GSVA (Poisson kernel)
#| eval: !expr requireNamespace("GSVA", quietly = TRUE)

# update this to use for kcdf = "Poisson"
gsvaParPoisson <- gsvaParam(X1, gs, kcdf = "Poisson")

gsva_res_poisson <- as.matrix(
  gsva(gsvaParPoisson, verbose=FALSE)
)

# Check the correlation between the two
correlations <- diag(
  cor(bixverse_res_poisson, gsva_res_poisson)
)

# basically the same results
same_res <- all(correlations >= 0.99)

print(
  paste(
    "GSVA and bixverse return (basically) the",
    sprintf("same results for GSVA (Poisson): %s", same_res)
  )
)

gsva_res_poisson[1:5, 1:5]
```

And speed comparisons for the Poisson kernel version between `GSVA` and
`bixverse`: 

```{r}
#| label: speed comparison (Poisson)
#| eval: !expr requireNamespace(c("GSVA", "microbenchmark"), quietly = TRUE)

microbenchmark::microbenchmark(
  gsva = {
    gsvaPar <- gsvaParam(X1, gs, kcdf = "Poisson")
    gsva(gsvaPar, verbose = FALSE)
  },
  bixverse = calc_gsva(
    exp = X1,
    pathways = gs,
    gaussian = FALSE
  ),
  times = 10L
)
```

### single sample GSEA

ssGSEA was first described in [Barbie et al.](https://www.nature.com/articles/nature08460) and there is an implementation in `GSVA`. Compared to `GSVA` there
is no normalisation across samples based on the kcdf. `bixverse` also provides
a Rust optimised version of this algorithm.

```{r}
#| label: bixverse ssGSEA

bixverse_res_ssgsea <- calc_ssgsea(
  exp = X,
  pathways = gs
)

bixverse_res_ssgsea[1:5, 1:5]
```

This is the way you would run the ssGSEA algorithm in the GSVA package.

```{r}
#| label: original ssGSEA
#| eval: !expr requireNamespace("GSVA", quietly = TRUE)

# update this to the ssgsea parameters
ssgseaPar <- ssgseaParam(X, gs)

ssgsea_res <- as.matrix(
  gsva(ssgseaPar, verbose=FALSE)
)

# Check the correlation between the two
correlations <- diag(
  cor(bixverse_res_ssgsea, ssgsea_res)
)

# basically the same results
same_res <- all(correlations >= 0.99)

print(
  paste(
    "GSVA and bixverse return (basically) the",
    sprintf("same results for ssGSEA: %s", same_res)
  )
)

ssgsea_res[1:5, 1:5]
```

Again, you should observe speed improvements thanks to algorithm improvements
and leveraging Rust's performance.

```{r}
#| label: speed comparison ssgsea
#| eval: !expr requireNamespace(c("GSVA", "microbenchmark"), quietly = TRUE)

microbenchmark::microbenchmark(
  gsva = {
    ssgseaPar <- ssgseaParam(X, gs)
    gsva(ssgseaPar, verbose = FALSE)
  },
  bixverse = calc_ssgsea(
    exp = X,
    pathways = gs
  ),
  times = 10L
)
```
